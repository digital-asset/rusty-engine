// This file is generated by rust-protobuf 2.1.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Unit {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Unit {
    pub fn new() -> Unit {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Unit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Unit {
        Unit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Unit>(
                    "Unit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Unit {
        static mut instance: ::protobuf::lazy::Lazy<Unit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Unit,
        };
        unsafe {
            instance.get(Unit::new)
        }
    }
}

impl ::protobuf::Clear for Unit {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Unit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Unit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PackageRef {
    // message oneof groups
    pub Sum: ::std::option::Option<PackageRef_oneof_Sum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum PackageRef_oneof_Sum {
    field_self(Unit),
    package_id(::std::string::String),
}

impl PackageRef {
    pub fn new() -> PackageRef {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Unit self = 1;

    pub fn clear_field_self(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_field_self(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(PackageRef_oneof_Sum::field_self(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_self(&mut self, v: Unit) {
        self.Sum = ::std::option::Option::Some(PackageRef_oneof_Sum::field_self(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_self(&mut self) -> &mut Unit {
        if let ::std::option::Option::Some(PackageRef_oneof_Sum::field_self(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(PackageRef_oneof_Sum::field_self(Unit::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(PackageRef_oneof_Sum::field_self(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_self(&mut self) -> Unit {
        if self.has_field_self() {
            match self.Sum.take() {
                ::std::option::Option::Some(PackageRef_oneof_Sum::field_self(v)) => v,
                _ => panic!(),
            }
        } else {
            Unit::new()
        }
    }

    pub fn get_field_self(&self) -> &Unit {
        match self.Sum {
            ::std::option::Option::Some(PackageRef_oneof_Sum::field_self(ref v)) => v,
            _ => Unit::default_instance(),
        }
    }

    // string package_id = 2;

    pub fn clear_package_id(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(PackageRef_oneof_Sum::package_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: ::std::string::String) {
        self.Sum = ::std::option::Option::Some(PackageRef_oneof_Sum::package_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_package_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(PackageRef_oneof_Sum::package_id(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(PackageRef_oneof_Sum::package_id(::std::string::String::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(PackageRef_oneof_Sum::package_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_package_id(&mut self) -> ::std::string::String {
        if self.has_package_id() {
            match self.Sum.take() {
                ::std::option::Option::Some(PackageRef_oneof_Sum::package_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_package_id(&self) -> &str {
        match self.Sum {
            ::std::option::Option::Some(PackageRef_oneof_Sum::package_id(ref v)) => v,
            _ => "",
        }
    }
}

impl ::protobuf::Message for PackageRef {
    fn is_initialized(&self) -> bool {
        if let Some(PackageRef_oneof_Sum::field_self(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(PackageRef_oneof_Sum::field_self(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(PackageRef_oneof_Sum::package_id(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &PackageRef_oneof_Sum::field_self(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &PackageRef_oneof_Sum::package_id(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &PackageRef_oneof_Sum::field_self(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &PackageRef_oneof_Sum::package_id(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PackageRef {
        PackageRef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Unit>(
                    "self",
                    PackageRef::has_field_self,
                    PackageRef::get_field_self,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "package_id",
                    PackageRef::has_package_id,
                    PackageRef::get_package_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PackageRef>(
                    "PackageRef",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PackageRef {
        static mut instance: ::protobuf::lazy::Lazy<PackageRef> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PackageRef,
        };
        unsafe {
            instance.get(PackageRef::new)
        }
    }
}

impl ::protobuf::Clear for PackageRef {
    fn clear(&mut self) {
        self.clear_field_self();
        self.clear_package_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PackageRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PackageRef {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DottedName {
    // message fields
    pub segments: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DottedName {
    pub fn new() -> DottedName {
        ::std::default::Default::default()
    }

    // repeated string segments = 1;

    pub fn clear_segments(&mut self) {
        self.segments.clear();
    }

    // Param is passed by value, moved
    pub fn set_segments(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.segments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_segments(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.segments
    }

    // Take field
    pub fn take_segments(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.segments, ::protobuf::RepeatedField::new())
    }

    pub fn get_segments(&self) -> &[::std::string::String] {
        &self.segments
    }
}

impl ::protobuf::Message for DottedName {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.segments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.segments {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.segments {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DottedName {
        DottedName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "segments",
                    |m: &DottedName| { &m.segments },
                    |m: &mut DottedName| { &mut m.segments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DottedName>(
                    "DottedName",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DottedName {
        static mut instance: ::protobuf::lazy::Lazy<DottedName> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DottedName,
        };
        unsafe {
            instance.get(DottedName::new)
        }
    }
}

impl ::protobuf::Clear for DottedName {
    fn clear(&mut self) {
        self.clear_segments();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DottedName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DottedName {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModuleRef {
    // message fields
    pub package_ref: ::protobuf::SingularPtrField<PackageRef>,
    pub module_name: ::protobuf::SingularPtrField<DottedName>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ModuleRef {
    pub fn new() -> ModuleRef {
        ::std::default::Default::default()
    }

    // .daml_lf_1.PackageRef package_ref = 1;

    pub fn clear_package_ref(&mut self) {
        self.package_ref.clear();
    }

    pub fn has_package_ref(&self) -> bool {
        self.package_ref.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_ref(&mut self, v: PackageRef) {
        self.package_ref = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package_ref(&mut self) -> &mut PackageRef {
        if self.package_ref.is_none() {
            self.package_ref.set_default();
        }
        self.package_ref.as_mut().unwrap()
    }

    // Take field
    pub fn take_package_ref(&mut self) -> PackageRef {
        self.package_ref.take().unwrap_or_else(|| PackageRef::new())
    }

    pub fn get_package_ref(&self) -> &PackageRef {
        self.package_ref.as_ref().unwrap_or_else(|| PackageRef::default_instance())
    }

    // .daml_lf_1.DottedName module_name = 2;

    pub fn clear_module_name(&mut self) {
        self.module_name.clear();
    }

    pub fn has_module_name(&self) -> bool {
        self.module_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_name(&mut self, v: DottedName) {
        self.module_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_name(&mut self) -> &mut DottedName {
        if self.module_name.is_none() {
            self.module_name.set_default();
        }
        self.module_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_name(&mut self) -> DottedName {
        self.module_name.take().unwrap_or_else(|| DottedName::new())
    }

    pub fn get_module_name(&self) -> &DottedName {
        self.module_name.as_ref().unwrap_or_else(|| DottedName::default_instance())
    }
}

impl ::protobuf::Message for ModuleRef {
    fn is_initialized(&self) -> bool {
        for v in &self.package_ref {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.module_name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.package_ref)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.module_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.package_ref.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.module_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.package_ref.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.module_name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModuleRef {
        ModuleRef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PackageRef>>(
                    "package_ref",
                    |m: &ModuleRef| { &m.package_ref },
                    |m: &mut ModuleRef| { &mut m.package_ref },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DottedName>>(
                    "module_name",
                    |m: &ModuleRef| { &m.module_name },
                    |m: &mut ModuleRef| { &mut m.module_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModuleRef>(
                    "ModuleRef",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModuleRef {
        static mut instance: ::protobuf::lazy::Lazy<ModuleRef> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModuleRef,
        };
        unsafe {
            instance.get(ModuleRef::new)
        }
    }
}

impl ::protobuf::Clear for ModuleRef {
    fn clear(&mut self) {
        self.clear_package_ref();
        self.clear_module_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModuleRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleRef {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeConName {
    // message fields
    pub module: ::protobuf::SingularPtrField<ModuleRef>,
    pub name: ::protobuf::SingularPtrField<DottedName>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TypeConName {
    pub fn new() -> TypeConName {
        ::std::default::Default::default()
    }

    // .daml_lf_1.ModuleRef module = 1;

    pub fn clear_module(&mut self) {
        self.module.clear();
    }

    pub fn has_module(&self) -> bool {
        self.module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: ModuleRef) {
        self.module = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module(&mut self) -> &mut ModuleRef {
        if self.module.is_none() {
            self.module.set_default();
        }
        self.module.as_mut().unwrap()
    }

    // Take field
    pub fn take_module(&mut self) -> ModuleRef {
        self.module.take().unwrap_or_else(|| ModuleRef::new())
    }

    pub fn get_module(&self) -> &ModuleRef {
        self.module.as_ref().unwrap_or_else(|| ModuleRef::default_instance())
    }

    // .daml_lf_1.DottedName name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: DottedName) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut DottedName {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> DottedName {
        self.name.take().unwrap_or_else(|| DottedName::new())
    }

    pub fn get_name(&self) -> &DottedName {
        self.name.as_ref().unwrap_or_else(|| DottedName::default_instance())
    }
}

impl ::protobuf::Message for TypeConName {
    fn is_initialized(&self) -> bool {
        for v in &self.module {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.module)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.module.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeConName {
        TypeConName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModuleRef>>(
                    "module",
                    |m: &TypeConName| { &m.module },
                    |m: &mut TypeConName| { &mut m.module },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DottedName>>(
                    "name",
                    |m: &TypeConName| { &m.name },
                    |m: &mut TypeConName| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeConName>(
                    "TypeConName",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeConName {
        static mut instance: ::protobuf::lazy::Lazy<TypeConName> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeConName,
        };
        unsafe {
            instance.get(TypeConName::new)
        }
    }
}

impl ::protobuf::Clear for TypeConName {
    fn clear(&mut self) {
        self.clear_module();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeConName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeConName {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValName {
    // message fields
    pub module: ::protobuf::SingularPtrField<ModuleRef>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ValName {
    pub fn new() -> ValName {
        ::std::default::Default::default()
    }

    // .daml_lf_1.ModuleRef module = 1;

    pub fn clear_module(&mut self) {
        self.module.clear();
    }

    pub fn has_module(&self) -> bool {
        self.module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: ModuleRef) {
        self.module = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module(&mut self) -> &mut ModuleRef {
        if self.module.is_none() {
            self.module.set_default();
        }
        self.module.as_mut().unwrap()
    }

    // Take field
    pub fn take_module(&mut self) -> ModuleRef {
        self.module.take().unwrap_or_else(|| ModuleRef::new())
    }

    pub fn get_module(&self) -> &ModuleRef {
        self.module.as_ref().unwrap_or_else(|| ModuleRef::default_instance())
    }

    // string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for ValName {
    fn is_initialized(&self) -> bool {
        for v in &self.module {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.module)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.module.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValName {
        ValName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModuleRef>>(
                    "module",
                    |m: &ValName| { &m.module },
                    |m: &mut ValName| { &mut m.module },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ValName| { &m.name },
                    |m: &mut ValName| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ValName>(
                    "ValName",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ValName {
        static mut instance: ::protobuf::lazy::Lazy<ValName> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ValName,
        };
        unsafe {
            instance.get(ValName::new)
        }
    }
}

impl ::protobuf::Clear for ValName {
    fn clear(&mut self) {
        self.clear_module();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValName {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldWithType {
    // message fields
    pub field: ::std::string::String,
    pub field_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl FieldWithType {
    pub fn new() -> FieldWithType {
        ::std::default::Default::default()
    }

    // string field = 1;

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    pub fn get_field(&self) -> &str {
        &self.field
    }

    // .daml_lf_1.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
}

impl ::protobuf::Message for FieldWithType {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.field.is_empty() {
            os.write_string(1, &self.field)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldWithType {
        FieldWithType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field",
                    |m: &FieldWithType| { &m.field },
                    |m: &mut FieldWithType| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &FieldWithType| { &m.field_type },
                    |m: &mut FieldWithType| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FieldWithType>(
                    "FieldWithType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FieldWithType {
        static mut instance: ::protobuf::lazy::Lazy<FieldWithType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FieldWithType,
        };
        unsafe {
            instance.get(FieldWithType::new)
        }
    }
}

impl ::protobuf::Clear for FieldWithType {
    fn clear(&mut self) {
        self.clear_field();
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldWithType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldWithType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VarWithType {
    // message fields
    pub var: ::std::string::String,
    pub field_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VarWithType {
    pub fn new() -> VarWithType {
        ::std::default::Default::default()
    }

    // string var = 1;

    pub fn clear_var(&mut self) {
        self.var.clear();
    }

    // Param is passed by value, moved
    pub fn set_var(&mut self, v: ::std::string::String) {
        self.var = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_var(&mut self) -> &mut ::std::string::String {
        &mut self.var
    }

    // Take field
    pub fn take_var(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.var, ::std::string::String::new())
    }

    pub fn get_var(&self) -> &str {
        &self.var
    }

    // .daml_lf_1.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
}

impl ::protobuf::Message for VarWithType {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.var)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.var.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.var);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.var.is_empty() {
            os.write_string(1, &self.var)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VarWithType {
        VarWithType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "var",
                    |m: &VarWithType| { &m.var },
                    |m: &mut VarWithType| { &mut m.var },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &VarWithType| { &m.field_type },
                    |m: &mut VarWithType| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VarWithType>(
                    "VarWithType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VarWithType {
        static mut instance: ::protobuf::lazy::Lazy<VarWithType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VarWithType,
        };
        unsafe {
            instance.get(VarWithType::new)
        }
    }
}

impl ::protobuf::Clear for VarWithType {
    fn clear(&mut self) {
        self.clear_var();
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VarWithType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VarWithType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeVarWithKind {
    // message fields
    pub var: ::std::string::String,
    pub kind: ::protobuf::SingularPtrField<Kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TypeVarWithKind {
    pub fn new() -> TypeVarWithKind {
        ::std::default::Default::default()
    }

    // string var = 1;

    pub fn clear_var(&mut self) {
        self.var.clear();
    }

    // Param is passed by value, moved
    pub fn set_var(&mut self, v: ::std::string::String) {
        self.var = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_var(&mut self) -> &mut ::std::string::String {
        &mut self.var
    }

    // Take field
    pub fn take_var(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.var, ::std::string::String::new())
    }

    pub fn get_var(&self) -> &str {
        &self.var
    }

    // .daml_lf_1.Kind kind = 2;

    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: Kind) {
        self.kind = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut Kind {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> Kind {
        self.kind.take().unwrap_or_else(|| Kind::new())
    }

    pub fn get_kind(&self) -> &Kind {
        self.kind.as_ref().unwrap_or_else(|| Kind::default_instance())
    }
}

impl ::protobuf::Message for TypeVarWithKind {
    fn is_initialized(&self) -> bool {
        for v in &self.kind {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.var)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kind)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.var.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.var);
        }
        if let Some(ref v) = self.kind.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.var.is_empty() {
            os.write_string(1, &self.var)?;
        }
        if let Some(ref v) = self.kind.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeVarWithKind {
        TypeVarWithKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "var",
                    |m: &TypeVarWithKind| { &m.var },
                    |m: &mut TypeVarWithKind| { &mut m.var },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Kind>>(
                    "kind",
                    |m: &TypeVarWithKind| { &m.kind },
                    |m: &mut TypeVarWithKind| { &mut m.kind },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeVarWithKind>(
                    "TypeVarWithKind",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeVarWithKind {
        static mut instance: ::protobuf::lazy::Lazy<TypeVarWithKind> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeVarWithKind,
        };
        unsafe {
            instance.get(TypeVarWithKind::new)
        }
    }
}

impl ::protobuf::Clear for TypeVarWithKind {
    fn clear(&mut self) {
        self.clear_var();
        self.clear_kind();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeVarWithKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeVarWithKind {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldWithExpr {
    // message fields
    pub field: ::std::string::String,
    pub expr: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl FieldWithExpr {
    pub fn new() -> FieldWithExpr {
        ::std::default::Default::default()
    }

    // string field = 1;

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    pub fn get_field(&self) -> &str {
        &self.field
    }

    // .daml_lf_1.Expr expr = 2;

    pub fn clear_expr(&mut self) {
        self.expr.clear();
    }

    pub fn has_expr(&self) -> bool {
        self.expr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expr(&mut self, v: Expr) {
        self.expr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expr(&mut self) -> &mut Expr {
        if self.expr.is_none() {
            self.expr.set_default();
        }
        self.expr.as_mut().unwrap()
    }

    // Take field
    pub fn take_expr(&mut self) -> Expr {
        self.expr.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_expr(&self) -> &Expr {
        self.expr.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for FieldWithExpr {
    fn is_initialized(&self) -> bool {
        for v in &self.expr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field);
        }
        if let Some(ref v) = self.expr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.field.is_empty() {
            os.write_string(1, &self.field)?;
        }
        if let Some(ref v) = self.expr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldWithExpr {
        FieldWithExpr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field",
                    |m: &FieldWithExpr| { &m.field },
                    |m: &mut FieldWithExpr| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "expr",
                    |m: &FieldWithExpr| { &m.expr },
                    |m: &mut FieldWithExpr| { &mut m.expr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FieldWithExpr>(
                    "FieldWithExpr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FieldWithExpr {
        static mut instance: ::protobuf::lazy::Lazy<FieldWithExpr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FieldWithExpr,
        };
        unsafe {
            instance.get(FieldWithExpr::new)
        }
    }
}

impl ::protobuf::Clear for FieldWithExpr {
    fn clear(&mut self) {
        self.clear_field();
        self.clear_expr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldWithExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldWithExpr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Binding {
    // message fields
    pub binder: ::protobuf::SingularPtrField<VarWithType>,
    pub bound: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Binding {
    pub fn new() -> Binding {
        ::std::default::Default::default()
    }

    // .daml_lf_1.VarWithType binder = 1;

    pub fn clear_binder(&mut self) {
        self.binder.clear();
    }

    pub fn has_binder(&self) -> bool {
        self.binder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binder(&mut self, v: VarWithType) {
        self.binder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binder(&mut self) -> &mut VarWithType {
        if self.binder.is_none() {
            self.binder.set_default();
        }
        self.binder.as_mut().unwrap()
    }

    // Take field
    pub fn take_binder(&mut self) -> VarWithType {
        self.binder.take().unwrap_or_else(|| VarWithType::new())
    }

    pub fn get_binder(&self) -> &VarWithType {
        self.binder.as_ref().unwrap_or_else(|| VarWithType::default_instance())
    }

    // .daml_lf_1.Expr bound = 2;

    pub fn clear_bound(&mut self) {
        self.bound.clear();
    }

    pub fn has_bound(&self) -> bool {
        self.bound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bound(&mut self, v: Expr) {
        self.bound = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bound(&mut self) -> &mut Expr {
        if self.bound.is_none() {
            self.bound.set_default();
        }
        self.bound.as_mut().unwrap()
    }

    // Take field
    pub fn take_bound(&mut self) -> Expr {
        self.bound.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_bound(&self) -> &Expr {
        self.bound.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Binding {
    fn is_initialized(&self) -> bool {
        for v in &self.binder {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bound {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.binder)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bound)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.binder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bound.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.binder.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bound.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Binding {
        Binding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VarWithType>>(
                    "binder",
                    |m: &Binding| { &m.binder },
                    |m: &mut Binding| { &mut m.binder },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "bound",
                    |m: &Binding| { &m.bound },
                    |m: &mut Binding| { &mut m.bound },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Binding>(
                    "Binding",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Binding {
        static mut instance: ::protobuf::lazy::Lazy<Binding> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Binding,
        };
        unsafe {
            instance.get(Binding::new)
        }
    }
}

impl ::protobuf::Clear for Binding {
    fn clear(&mut self) {
        self.clear_binder();
        self.clear_bound();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Binding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Binding {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Kind {
    // message oneof groups
    pub Sum: ::std::option::Option<Kind_oneof_Sum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Kind_oneof_Sum {
    star(Unit),
    arrow(Kind_Arrow),
}

impl Kind {
    pub fn new() -> Kind {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Unit star = 1;

    pub fn clear_star(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_star(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Kind_oneof_Sum::star(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_star(&mut self, v: Unit) {
        self.Sum = ::std::option::Option::Some(Kind_oneof_Sum::star(v))
    }

    // Mutable pointer to the field.
    pub fn mut_star(&mut self) -> &mut Unit {
        if let ::std::option::Option::Some(Kind_oneof_Sum::star(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Kind_oneof_Sum::star(Unit::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Kind_oneof_Sum::star(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_star(&mut self) -> Unit {
        if self.has_star() {
            match self.Sum.take() {
                ::std::option::Option::Some(Kind_oneof_Sum::star(v)) => v,
                _ => panic!(),
            }
        } else {
            Unit::new()
        }
    }

    pub fn get_star(&self) -> &Unit {
        match self.Sum {
            ::std::option::Option::Some(Kind_oneof_Sum::star(ref v)) => v,
            _ => Unit::default_instance(),
        }
    }

    // .daml_lf_1.Kind.Arrow arrow = 2;

    pub fn clear_arrow(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_arrow(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Kind_oneof_Sum::arrow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_arrow(&mut self, v: Kind_Arrow) {
        self.Sum = ::std::option::Option::Some(Kind_oneof_Sum::arrow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_arrow(&mut self) -> &mut Kind_Arrow {
        if let ::std::option::Option::Some(Kind_oneof_Sum::arrow(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Kind_oneof_Sum::arrow(Kind_Arrow::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Kind_oneof_Sum::arrow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_arrow(&mut self) -> Kind_Arrow {
        if self.has_arrow() {
            match self.Sum.take() {
                ::std::option::Option::Some(Kind_oneof_Sum::arrow(v)) => v,
                _ => panic!(),
            }
        } else {
            Kind_Arrow::new()
        }
    }

    pub fn get_arrow(&self) -> &Kind_Arrow {
        match self.Sum {
            ::std::option::Option::Some(Kind_oneof_Sum::arrow(ref v)) => v,
            _ => Kind_Arrow::default_instance(),
        }
    }
}

impl ::protobuf::Message for Kind {
    fn is_initialized(&self) -> bool {
        if let Some(Kind_oneof_Sum::star(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Kind_oneof_Sum::arrow(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Kind_oneof_Sum::star(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Kind_oneof_Sum::arrow(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Kind_oneof_Sum::star(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Kind_oneof_Sum::arrow(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Kind_oneof_Sum::star(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Kind_oneof_Sum::arrow(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Kind {
        Kind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Unit>(
                    "star",
                    Kind::has_star,
                    Kind::get_star,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Kind_Arrow>(
                    "arrow",
                    Kind::has_arrow,
                    Kind::get_arrow,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Kind>(
                    "Kind",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Kind {
        static mut instance: ::protobuf::lazy::Lazy<Kind> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Kind,
        };
        unsafe {
            instance.get(Kind::new)
        }
    }
}

impl ::protobuf::Clear for Kind {
    fn clear(&mut self) {
        self.clear_star();
        self.clear_arrow();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Kind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Kind_Arrow {
    // message fields
    pub params: ::protobuf::RepeatedField<Kind>,
    pub result: ::protobuf::SingularPtrField<Kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Kind_Arrow {
    pub fn new() -> Kind_Arrow {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.Kind params = 1;

    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<Kind>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<Kind> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<Kind> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }

    pub fn get_params(&self) -> &[Kind] {
        &self.params
    }

    // .daml_lf_1.Kind result = 2;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Kind) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Kind {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Kind {
        self.result.take().unwrap_or_else(|| Kind::new())
    }

    pub fn get_result(&self) -> &Kind {
        self.result.as_ref().unwrap_or_else(|| Kind::default_instance())
    }
}

impl ::protobuf::Message for Kind_Arrow {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.params)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.params {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Kind_Arrow {
        Kind_Arrow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Kind>>(
                    "params",
                    |m: &Kind_Arrow| { &m.params },
                    |m: &mut Kind_Arrow| { &mut m.params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Kind>>(
                    "result",
                    |m: &Kind_Arrow| { &m.result },
                    |m: &mut Kind_Arrow| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Kind_Arrow>(
                    "Kind_Arrow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Kind_Arrow {
        static mut instance: ::protobuf::lazy::Lazy<Kind_Arrow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Kind_Arrow,
        };
        unsafe {
            instance.get(Kind_Arrow::new)
        }
    }
}

impl ::protobuf::Clear for Kind_Arrow {
    fn clear(&mut self) {
        self.clear_params();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Kind_Arrow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Kind_Arrow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type {
    // message oneof groups
    pub Sum: ::std::option::Option<Type_oneof_Sum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Type_oneof_Sum {
    var(Type_Var),
    con(Type_Con),
    prim(Type_Prim),
    fun(Type_Fun),
    forall(Type_Forall),
    tuple(Type_Tuple),
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type.Var var = 1;

    pub fn clear_var(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_var(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::var(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_var(&mut self, v: Type_Var) {
        self.Sum = ::std::option::Option::Some(Type_oneof_Sum::var(v))
    }

    // Mutable pointer to the field.
    pub fn mut_var(&mut self) -> &mut Type_Var {
        if let ::std::option::Option::Some(Type_oneof_Sum::var(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Type_oneof_Sum::var(Type_Var::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::var(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_var(&mut self) -> Type_Var {
        if self.has_var() {
            match self.Sum.take() {
                ::std::option::Option::Some(Type_oneof_Sum::var(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_Var::new()
        }
    }

    pub fn get_var(&self) -> &Type_Var {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::var(ref v)) => v,
            _ => Type_Var::default_instance(),
        }
    }

    // .daml_lf_1.Type.Con con = 2;

    pub fn clear_con(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_con(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::con(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_con(&mut self, v: Type_Con) {
        self.Sum = ::std::option::Option::Some(Type_oneof_Sum::con(v))
    }

    // Mutable pointer to the field.
    pub fn mut_con(&mut self) -> &mut Type_Con {
        if let ::std::option::Option::Some(Type_oneof_Sum::con(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Type_oneof_Sum::con(Type_Con::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::con(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_con(&mut self) -> Type_Con {
        if self.has_con() {
            match self.Sum.take() {
                ::std::option::Option::Some(Type_oneof_Sum::con(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_Con::new()
        }
    }

    pub fn get_con(&self) -> &Type_Con {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::con(ref v)) => v,
            _ => Type_Con::default_instance(),
        }
    }

    // .daml_lf_1.Type.Prim prim = 3;

    pub fn clear_prim(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_prim(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::prim(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prim(&mut self, v: Type_Prim) {
        self.Sum = ::std::option::Option::Some(Type_oneof_Sum::prim(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prim(&mut self) -> &mut Type_Prim {
        if let ::std::option::Option::Some(Type_oneof_Sum::prim(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Type_oneof_Sum::prim(Type_Prim::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::prim(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prim(&mut self) -> Type_Prim {
        if self.has_prim() {
            match self.Sum.take() {
                ::std::option::Option::Some(Type_oneof_Sum::prim(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_Prim::new()
        }
    }

    pub fn get_prim(&self) -> &Type_Prim {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::prim(ref v)) => v,
            _ => Type_Prim::default_instance(),
        }
    }

    // .daml_lf_1.Type.Fun fun = 4;

    pub fn clear_fun(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_fun(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::fun(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fun(&mut self, v: Type_Fun) {
        self.Sum = ::std::option::Option::Some(Type_oneof_Sum::fun(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fun(&mut self) -> &mut Type_Fun {
        if let ::std::option::Option::Some(Type_oneof_Sum::fun(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Type_oneof_Sum::fun(Type_Fun::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::fun(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fun(&mut self) -> Type_Fun {
        if self.has_fun() {
            match self.Sum.take() {
                ::std::option::Option::Some(Type_oneof_Sum::fun(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_Fun::new()
        }
    }

    pub fn get_fun(&self) -> &Type_Fun {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::fun(ref v)) => v,
            _ => Type_Fun::default_instance(),
        }
    }

    // .daml_lf_1.Type.Forall forall = 5;

    pub fn clear_forall(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_forall(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::forall(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_forall(&mut self, v: Type_Forall) {
        self.Sum = ::std::option::Option::Some(Type_oneof_Sum::forall(v))
    }

    // Mutable pointer to the field.
    pub fn mut_forall(&mut self) -> &mut Type_Forall {
        if let ::std::option::Option::Some(Type_oneof_Sum::forall(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Type_oneof_Sum::forall(Type_Forall::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::forall(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_forall(&mut self) -> Type_Forall {
        if self.has_forall() {
            match self.Sum.take() {
                ::std::option::Option::Some(Type_oneof_Sum::forall(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_Forall::new()
        }
    }

    pub fn get_forall(&self) -> &Type_Forall {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::forall(ref v)) => v,
            _ => Type_Forall::default_instance(),
        }
    }

    // .daml_lf_1.Type.Tuple tuple = 7;

    pub fn clear_tuple(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_tuple(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::tuple(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tuple(&mut self, v: Type_Tuple) {
        self.Sum = ::std::option::Option::Some(Type_oneof_Sum::tuple(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tuple(&mut self) -> &mut Type_Tuple {
        if let ::std::option::Option::Some(Type_oneof_Sum::tuple(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Type_oneof_Sum::tuple(Type_Tuple::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::tuple(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tuple(&mut self) -> Type_Tuple {
        if self.has_tuple() {
            match self.Sum.take() {
                ::std::option::Option::Some(Type_oneof_Sum::tuple(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_Tuple::new()
        }
    }

    pub fn get_tuple(&self) -> &Type_Tuple {
        match self.Sum {
            ::std::option::Option::Some(Type_oneof_Sum::tuple(ref v)) => v,
            _ => Type_Tuple::default_instance(),
        }
    }
}

impl ::protobuf::Message for Type {
    fn is_initialized(&self) -> bool {
        if let Some(Type_oneof_Sum::var(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_Sum::con(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_Sum::prim(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_Sum::fun(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_Sum::forall(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_Sum::tuple(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Type_oneof_Sum::var(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Type_oneof_Sum::con(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Type_oneof_Sum::prim(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Type_oneof_Sum::fun(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Type_oneof_Sum::forall(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Type_oneof_Sum::tuple(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Type_oneof_Sum::var(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_Sum::con(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_Sum::prim(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_Sum::fun(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_Sum::forall(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_Sum::tuple(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Type_oneof_Sum::var(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_Sum::con(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_Sum::prim(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_Sum::fun(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_Sum::forall(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_Sum::tuple(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type {
        Type::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_Var>(
                    "var",
                    Type::has_var,
                    Type::get_var,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_Con>(
                    "con",
                    Type::has_con,
                    Type::get_con,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_Prim>(
                    "prim",
                    Type::has_prim,
                    Type::get_prim,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_Fun>(
                    "fun",
                    Type::has_fun,
                    Type::get_fun,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_Forall>(
                    "forall",
                    Type::has_forall,
                    Type::get_forall,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_Tuple>(
                    "tuple",
                    Type::has_tuple,
                    Type::get_tuple,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type>(
                    "Type",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type {
        static mut instance: ::protobuf::lazy::Lazy<Type> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type,
        };
        unsafe {
            instance.get(Type::new)
        }
    }
}

impl ::protobuf::Clear for Type {
    fn clear(&mut self) {
        self.clear_var();
        self.clear_con();
        self.clear_prim();
        self.clear_fun();
        self.clear_forall();
        self.clear_tuple();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Var {
    // message fields
    pub var: ::std::string::String,
    pub args: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Type_Var {
    pub fn new() -> Type_Var {
        ::std::default::Default::default()
    }

    // string var = 1;

    pub fn clear_var(&mut self) {
        self.var.clear();
    }

    // Param is passed by value, moved
    pub fn set_var(&mut self, v: ::std::string::String) {
        self.var = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_var(&mut self) -> &mut ::std::string::String {
        &mut self.var
    }

    // Take field
    pub fn take_var(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.var, ::std::string::String::new())
    }

    pub fn get_var(&self) -> &str {
        &self.var
    }

    // repeated .daml_lf_1.Type args = 2;

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    pub fn get_args(&self) -> &[Type] {
        &self.args
    }
}

impl ::protobuf::Message for Type_Var {
    fn is_initialized(&self) -> bool {
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.var)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.var.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.var);
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.var.is_empty() {
            os.write_string(1, &self.var)?;
        }
        for v in &self.args {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Var {
        Type_Var::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "var",
                    |m: &Type_Var| { &m.var },
                    |m: &mut Type_Var| { &mut m.var },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "args",
                    |m: &Type_Var| { &m.args },
                    |m: &mut Type_Var| { &mut m.args },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_Var>(
                    "Type_Var",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Var {
        static mut instance: ::protobuf::lazy::Lazy<Type_Var> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Var,
        };
        unsafe {
            instance.get(Type_Var::new)
        }
    }
}

impl ::protobuf::Clear for Type_Var {
    fn clear(&mut self) {
        self.clear_var();
        self.clear_args();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Var {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Var {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Con {
    // message fields
    pub tycon: ::protobuf::SingularPtrField<TypeConName>,
    pub args: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Type_Con {
    pub fn new() -> Type_Con {
        ::std::default::Default::default()
    }

    // .daml_lf_1.TypeConName tycon = 1;

    pub fn clear_tycon(&mut self) {
        self.tycon.clear();
    }

    pub fn has_tycon(&self) -> bool {
        self.tycon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tycon(&mut self, v: TypeConName) {
        self.tycon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tycon(&mut self) -> &mut TypeConName {
        if self.tycon.is_none() {
            self.tycon.set_default();
        }
        self.tycon.as_mut().unwrap()
    }

    // Take field
    pub fn take_tycon(&mut self) -> TypeConName {
        self.tycon.take().unwrap_or_else(|| TypeConName::new())
    }

    pub fn get_tycon(&self) -> &TypeConName {
        self.tycon.as_ref().unwrap_or_else(|| TypeConName::default_instance())
    }

    // repeated .daml_lf_1.Type args = 2;

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    pub fn get_args(&self) -> &[Type] {
        &self.args
    }
}

impl ::protobuf::Message for Type_Con {
    fn is_initialized(&self) -> bool {
        for v in &self.tycon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tycon)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tycon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tycon.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.args {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Con {
        Type_Con::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeConName>>(
                    "tycon",
                    |m: &Type_Con| { &m.tycon },
                    |m: &mut Type_Con| { &mut m.tycon },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "args",
                    |m: &Type_Con| { &m.args },
                    |m: &mut Type_Con| { &mut m.args },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_Con>(
                    "Type_Con",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Con {
        static mut instance: ::protobuf::lazy::Lazy<Type_Con> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Con,
        };
        unsafe {
            instance.get(Type_Con::new)
        }
    }
}

impl ::protobuf::Clear for Type_Con {
    fn clear(&mut self) {
        self.clear_tycon();
        self.clear_args();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Con {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Con {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Prim {
    // message fields
    pub prim: PrimType,
    pub args: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Type_Prim {
    pub fn new() -> Type_Prim {
        ::std::default::Default::default()
    }

    // .daml_lf_1.PrimType prim = 1;

    pub fn clear_prim(&mut self) {
        self.prim = PrimType::UNIT;
    }

    // Param is passed by value, moved
    pub fn set_prim(&mut self, v: PrimType) {
        self.prim = v;
    }

    pub fn get_prim(&self) -> PrimType {
        self.prim
    }

    // repeated .daml_lf_1.Type args = 2;

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    pub fn get_args(&self) -> &[Type] {
        &self.args
    }
}

impl ::protobuf::Message for Type_Prim {
    fn is_initialized(&self) -> bool {
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.prim, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.prim != PrimType::UNIT {
            my_size += ::protobuf::rt::enum_size(1, self.prim);
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.prim != PrimType::UNIT {
            os.write_enum(1, self.prim.value())?;
        }
        for v in &self.args {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Prim {
        Type_Prim::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PrimType>>(
                    "prim",
                    |m: &Type_Prim| { &m.prim },
                    |m: &mut Type_Prim| { &mut m.prim },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "args",
                    |m: &Type_Prim| { &m.args },
                    |m: &mut Type_Prim| { &mut m.args },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_Prim>(
                    "Type_Prim",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Prim {
        static mut instance: ::protobuf::lazy::Lazy<Type_Prim> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Prim,
        };
        unsafe {
            instance.get(Type_Prim::new)
        }
    }
}

impl ::protobuf::Clear for Type_Prim {
    fn clear(&mut self) {
        self.clear_prim();
        self.clear_args();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Prim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Prim {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Fun {
    // message fields
    pub params: ::protobuf::RepeatedField<Type>,
    pub result: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Type_Fun {
    pub fn new() -> Type_Fun {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.Type params = 1;

    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }

    pub fn get_params(&self) -> &[Type] {
        &self.params
    }

    // .daml_lf_1.Type result = 2;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Type) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Type {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Type {
        self.result.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_result(&self) -> &Type {
        self.result.as_ref().unwrap_or_else(|| Type::default_instance())
    }
}

impl ::protobuf::Message for Type_Fun {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.params)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.params {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Fun {
        Type_Fun::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "params",
                    |m: &Type_Fun| { &m.params },
                    |m: &mut Type_Fun| { &mut m.params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "result",
                    |m: &Type_Fun| { &m.result },
                    |m: &mut Type_Fun| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_Fun>(
                    "Type_Fun",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Fun {
        static mut instance: ::protobuf::lazy::Lazy<Type_Fun> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Fun,
        };
        unsafe {
            instance.get(Type_Fun::new)
        }
    }
}

impl ::protobuf::Clear for Type_Fun {
    fn clear(&mut self) {
        self.clear_params();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Fun {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Fun {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Forall {
    // message fields
    pub vars: ::protobuf::RepeatedField<TypeVarWithKind>,
    pub body: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Type_Forall {
    pub fn new() -> Type_Forall {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.TypeVarWithKind vars = 1;

    pub fn clear_vars(&mut self) {
        self.vars.clear();
    }

    // Param is passed by value, moved
    pub fn set_vars(&mut self, v: ::protobuf::RepeatedField<TypeVarWithKind>) {
        self.vars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vars(&mut self) -> &mut ::protobuf::RepeatedField<TypeVarWithKind> {
        &mut self.vars
    }

    // Take field
    pub fn take_vars(&mut self) -> ::protobuf::RepeatedField<TypeVarWithKind> {
        ::std::mem::replace(&mut self.vars, ::protobuf::RepeatedField::new())
    }

    pub fn get_vars(&self) -> &[TypeVarWithKind] {
        &self.vars
    }

    // .daml_lf_1.Type body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Type) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Type {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Type {
        self.body.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_body(&self) -> &Type {
        self.body.as_ref().unwrap_or_else(|| Type::default_instance())
    }
}

impl ::protobuf::Message for Type_Forall {
    fn is_initialized(&self) -> bool {
        for v in &self.vars {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vars)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vars {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Forall {
        Type_Forall::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeVarWithKind>>(
                    "vars",
                    |m: &Type_Forall| { &m.vars },
                    |m: &mut Type_Forall| { &mut m.vars },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "body",
                    |m: &Type_Forall| { &m.body },
                    |m: &mut Type_Forall| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_Forall>(
                    "Type_Forall",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Forall {
        static mut instance: ::protobuf::lazy::Lazy<Type_Forall> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Forall,
        };
        unsafe {
            instance.get(Type_Forall::new)
        }
    }
}

impl ::protobuf::Clear for Type_Forall {
    fn clear(&mut self) {
        self.clear_vars();
        self.clear_body();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Forall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Forall {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Tuple {
    // message fields
    pub fields: ::protobuf::RepeatedField<FieldWithType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Type_Tuple {
    pub fn new() -> Type_Tuple {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.FieldWithType fields = 1;

    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<FieldWithType>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<FieldWithType> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<FieldWithType> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }

    pub fn get_fields(&self) -> &[FieldWithType] {
        &self.fields
    }
}

impl ::protobuf::Message for Type_Tuple {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Tuple {
        Type_Tuple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldWithType>>(
                    "fields",
                    |m: &Type_Tuple| { &m.fields },
                    |m: &mut Type_Tuple| { &mut m.fields },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_Tuple>(
                    "Type_Tuple",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Tuple {
        static mut instance: ::protobuf::lazy::Lazy<Type_Tuple> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Tuple,
        };
        unsafe {
            instance.get(Type_Tuple::new)
        }
    }
}

impl ::protobuf::Clear for Type_Tuple {
    fn clear(&mut self) {
        self.clear_fields();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Tuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Tuple {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_App {
    // message fields
    pub tyfun: ::protobuf::SingularPtrField<Type>,
    pub args: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Type_App {
    pub fn new() -> Type_App {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type tyfun = 1;

    pub fn clear_tyfun(&mut self) {
        self.tyfun.clear();
    }

    pub fn has_tyfun(&self) -> bool {
        self.tyfun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tyfun(&mut self, v: Type) {
        self.tyfun = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tyfun(&mut self) -> &mut Type {
        if self.tyfun.is_none() {
            self.tyfun.set_default();
        }
        self.tyfun.as_mut().unwrap()
    }

    // Take field
    pub fn take_tyfun(&mut self) -> Type {
        self.tyfun.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_tyfun(&self) -> &Type {
        self.tyfun.as_ref().unwrap_or_else(|| Type::default_instance())
    }

    // repeated .daml_lf_1.Type args = 2;

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    pub fn get_args(&self) -> &[Type] {
        &self.args
    }
}

impl ::protobuf::Message for Type_App {
    fn is_initialized(&self) -> bool {
        for v in &self.tyfun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tyfun)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tyfun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tyfun.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.args {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_App {
        Type_App::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "tyfun",
                    |m: &Type_App| { &m.tyfun },
                    |m: &mut Type_App| { &mut m.tyfun },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "args",
                    |m: &Type_App| { &m.args },
                    |m: &mut Type_App| { &mut m.args },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_App>(
                    "Type_App",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_App {
        static mut instance: ::protobuf::lazy::Lazy<Type_App> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_App,
        };
        unsafe {
            instance.get(Type_App::new)
        }
    }
}

impl ::protobuf::Clear for Type_App {
    fn clear(&mut self) {
        self.clear_tyfun();
        self.clear_args();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_App {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrimLit {
    // message oneof groups
    pub Sum: ::std::option::Option<PrimLit_oneof_Sum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum PrimLit_oneof_Sum {
    int64(i64),
    decimal(::std::string::String),
    text(::std::string::String),
    timestamp(i64),
    party(::std::string::String),
    date(i32),
}

impl PrimLit {
    pub fn new() -> PrimLit {
        ::std::default::Default::default()
    }

    // sint64 int64 = 1;

    pub fn clear_int64(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_int64(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::int64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int64(&mut self, v: i64) {
        self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::int64(v))
    }

    pub fn get_int64(&self) -> i64 {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::int64(v)) => v,
            _ => 0,
        }
    }

    // string decimal = 2;

    pub fn clear_decimal(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_decimal(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::decimal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_decimal(&mut self, v: ::std::string::String) {
        self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::decimal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_decimal(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(PrimLit_oneof_Sum::decimal(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::decimal(::std::string::String::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::decimal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_decimal(&mut self) -> ::std::string::String {
        if self.has_decimal() {
            match self.Sum.take() {
                ::std::option::Option::Some(PrimLit_oneof_Sum::decimal(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_decimal(&self) -> &str {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::decimal(ref v)) => v,
            _ => "",
        }
    }

    // string text = 4;

    pub fn clear_text(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(PrimLit_oneof_Sum::text(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::text(::std::string::String::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        if self.has_text() {
            match self.Sum.take() {
                ::std::option::Option::Some(PrimLit_oneof_Sum::text(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_text(&self) -> &str {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::text(ref v)) => v,
            _ => "",
        }
    }

    // sfixed64 timestamp = 5;

    pub fn clear_timestamp(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::timestamp(v))
    }

    pub fn get_timestamp(&self) -> i64 {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::timestamp(v)) => v,
            _ => 0,
        }
    }

    // string party = 7;

    pub fn clear_party(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_party(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::party(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_party(&mut self, v: ::std::string::String) {
        self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::party(v))
    }

    // Mutable pointer to the field.
    pub fn mut_party(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(PrimLit_oneof_Sum::party(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::party(::std::string::String::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::party(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_party(&mut self) -> ::std::string::String {
        if self.has_party() {
            match self.Sum.take() {
                ::std::option::Option::Some(PrimLit_oneof_Sum::party(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_party(&self) -> &str {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::party(ref v)) => v,
            _ => "",
        }
    }

    // int32 date = 8;

    pub fn clear_date(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::date(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i32) {
        self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::date(v))
    }

    pub fn get_date(&self) -> i32 {
        match self.Sum {
            ::std::option::Option::Some(PrimLit_oneof_Sum::date(v)) => v,
            _ => 0,
        }
    }
}

impl ::protobuf::Message for PrimLit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::int64(is.read_sint64()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::decimal(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::text(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::timestamp(is.read_sfixed64()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::party(is.read_string()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(PrimLit_oneof_Sum::date(is.read_int32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &PrimLit_oneof_Sum::int64(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
                },
                &PrimLit_oneof_Sum::decimal(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &PrimLit_oneof_Sum::text(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
                &PrimLit_oneof_Sum::timestamp(v) => {
                    my_size += 9;
                },
                &PrimLit_oneof_Sum::party(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
                &PrimLit_oneof_Sum::date(v) => {
                    my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &PrimLit_oneof_Sum::int64(v) => {
                    os.write_sint64(1, v)?;
                },
                &PrimLit_oneof_Sum::decimal(ref v) => {
                    os.write_string(2, v)?;
                },
                &PrimLit_oneof_Sum::text(ref v) => {
                    os.write_string(4, v)?;
                },
                &PrimLit_oneof_Sum::timestamp(v) => {
                    os.write_sfixed64(5, v)?;
                },
                &PrimLit_oneof_Sum::party(ref v) => {
                    os.write_string(7, v)?;
                },
                &PrimLit_oneof_Sum::date(v) => {
                    os.write_int32(8, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrimLit {
        PrimLit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "int64",
                    PrimLit::has_int64,
                    PrimLit::get_int64,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "decimal",
                    PrimLit::has_decimal,
                    PrimLit::get_decimal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "text",
                    PrimLit::has_text,
                    PrimLit::get_text,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "timestamp",
                    PrimLit::has_timestamp,
                    PrimLit::get_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "party",
                    PrimLit::has_party,
                    PrimLit::get_party,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "date",
                    PrimLit::has_date,
                    PrimLit::get_date,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PrimLit>(
                    "PrimLit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PrimLit {
        static mut instance: ::protobuf::lazy::Lazy<PrimLit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PrimLit,
        };
        unsafe {
            instance.get(PrimLit::new)
        }
    }
}

impl ::protobuf::Clear for PrimLit {
    fn clear(&mut self) {
        self.clear_int64();
        self.clear_decimal();
        self.clear_text();
        self.clear_timestamp();
        self.clear_party();
        self.clear_date();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrimLit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimLit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Location {
    // message fields
    pub module: ::protobuf::SingularPtrField<ModuleRef>,
    pub range: ::protobuf::SingularPtrField<Location_Range>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    // .daml_lf_1.ModuleRef module = 1;

    pub fn clear_module(&mut self) {
        self.module.clear();
    }

    pub fn has_module(&self) -> bool {
        self.module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: ModuleRef) {
        self.module = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module(&mut self) -> &mut ModuleRef {
        if self.module.is_none() {
            self.module.set_default();
        }
        self.module.as_mut().unwrap()
    }

    // Take field
    pub fn take_module(&mut self) -> ModuleRef {
        self.module.take().unwrap_or_else(|| ModuleRef::new())
    }

    pub fn get_module(&self) -> &ModuleRef {
        self.module.as_ref().unwrap_or_else(|| ModuleRef::default_instance())
    }

    // .daml_lf_1.Location.Range range = 2;

    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Location_Range) {
        self.range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut Location_Range {
        if self.range.is_none() {
            self.range.set_default();
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> Location_Range {
        self.range.take().unwrap_or_else(|| Location_Range::new())
    }

    pub fn get_range(&self) -> &Location_Range {
        self.range.as_ref().unwrap_or_else(|| Location_Range::default_instance())
    }
}

impl ::protobuf::Message for Location {
    fn is_initialized(&self) -> bool {
        for v in &self.module {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.module)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.range)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.module.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.range.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Location {
        Location::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModuleRef>>(
                    "module",
                    |m: &Location| { &m.module },
                    |m: &mut Location| { &mut m.module },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Location_Range>>(
                    "range",
                    |m: &Location| { &m.range },
                    |m: &mut Location| { &mut m.range },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Location>(
                    "Location",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Location {
        static mut instance: ::protobuf::lazy::Lazy<Location> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Location,
        };
        unsafe {
            instance.get(Location::new)
        }
    }
}

impl ::protobuf::Clear for Location {
    fn clear(&mut self) {
        self.clear_module();
        self.clear_range();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Location_Range {
    // message fields
    pub start_line: i32,
    pub start_col: i32,
    pub end_line: i32,
    pub end_col: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Location_Range {
    pub fn new() -> Location_Range {
        ::std::default::Default::default()
    }

    // int32 start_line = 1;

    pub fn clear_start_line(&mut self) {
        self.start_line = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_line(&mut self, v: i32) {
        self.start_line = v;
    }

    pub fn get_start_line(&self) -> i32 {
        self.start_line
    }

    // int32 start_col = 2;

    pub fn clear_start_col(&mut self) {
        self.start_col = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_col(&mut self, v: i32) {
        self.start_col = v;
    }

    pub fn get_start_col(&self) -> i32 {
        self.start_col
    }

    // int32 end_line = 3;

    pub fn clear_end_line(&mut self) {
        self.end_line = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_line(&mut self, v: i32) {
        self.end_line = v;
    }

    pub fn get_end_line(&self) -> i32 {
        self.end_line
    }

    // int32 end_col = 4;

    pub fn clear_end_col(&mut self) {
        self.end_col = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_col(&mut self, v: i32) {
        self.end_col = v;
    }

    pub fn get_end_col(&self) -> i32 {
        self.end_col
    }
}

impl ::protobuf::Message for Location_Range {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start_line = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start_col = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end_line = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.end_col = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_line != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_line, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_col != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_col, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_line != 0 {
            my_size += ::protobuf::rt::value_size(3, self.end_line, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_col != 0 {
            my_size += ::protobuf::rt::value_size(4, self.end_col, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_line != 0 {
            os.write_int32(1, self.start_line)?;
        }
        if self.start_col != 0 {
            os.write_int32(2, self.start_col)?;
        }
        if self.end_line != 0 {
            os.write_int32(3, self.end_line)?;
        }
        if self.end_col != 0 {
            os.write_int32(4, self.end_col)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Location_Range {
        Location_Range::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "start_line",
                    |m: &Location_Range| { &m.start_line },
                    |m: &mut Location_Range| { &mut m.start_line },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "start_col",
                    |m: &Location_Range| { &m.start_col },
                    |m: &mut Location_Range| { &mut m.start_col },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "end_line",
                    |m: &Location_Range| { &m.end_line },
                    |m: &mut Location_Range| { &mut m.end_line },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "end_col",
                    |m: &Location_Range| { &m.end_col },
                    |m: &mut Location_Range| { &mut m.end_col },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Location_Range>(
                    "Location_Range",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Location_Range {
        static mut instance: ::protobuf::lazy::Lazy<Location_Range> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Location_Range,
        };
        unsafe {
            instance.get(Location_Range::new)
        }
    }
}

impl ::protobuf::Clear for Location_Range {
    fn clear(&mut self) {
        self.clear_start_line();
        self.clear_start_col();
        self.clear_end_line();
        self.clear_end_col();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Location_Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location_Range {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr {
    // message fields
    pub location: ::protobuf::SingularPtrField<Location>,
    // message oneof groups
    pub Sum: ::std::option::Option<Expr_oneof_Sum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Expr_oneof_Sum {
    var(::std::string::String),
    val(ValName),
    builtin(BuiltinFunction),
    prim_con(PrimCon),
    prim_lit(PrimLit),
    rec_con(Expr_RecCon),
    rec_proj(Expr_RecProj),
    variant_con(Expr_VariantCon),
    tuple_con(Expr_TupleCon),
    tuple_proj(Expr_TupleProj),
    app(Expr_App),
    ty_app(Expr_TyApp),
    abs(Expr_Abs),
    ty_abs(Expr_TyAbs),
    case(Case),
    field_let(Block),
    nil(Expr_Nil),
    cons(Expr_Cons),
    update(Update),
    scenario(Scenario),
    rec_upd(Expr_RecUpd),
    tuple_upd(Expr_TupleUpd),
}

impl Expr {
    pub fn new() -> Expr {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Location location = 25;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Location) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut Location {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> Location {
        self.location.take().unwrap_or_else(|| Location::new())
    }

    pub fn get_location(&self) -> &Location {
        self.location.as_ref().unwrap_or_else(|| Location::default_instance())
    }

    // string var = 1;

    pub fn clear_var(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_var(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::var(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_var(&mut self, v: ::std::string::String) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::var(v))
    }

    // Mutable pointer to the field.
    pub fn mut_var(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Expr_oneof_Sum::var(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::var(::std::string::String::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::var(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_var(&mut self) -> ::std::string::String {
        if self.has_var() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::var(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_var(&self) -> &str {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::var(ref v)) => v,
            _ => "",
        }
    }

    // .daml_lf_1.ValName val = 2;

    pub fn clear_val(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_val(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::val(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ValName) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::val(v))
    }

    // Mutable pointer to the field.
    pub fn mut_val(&mut self) -> &mut ValName {
        if let ::std::option::Option::Some(Expr_oneof_Sum::val(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::val(ValName::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::val(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_val(&mut self) -> ValName {
        if self.has_val() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::val(v)) => v,
                _ => panic!(),
            }
        } else {
            ValName::new()
        }
    }

    pub fn get_val(&self) -> &ValName {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::val(ref v)) => v,
            _ => ValName::default_instance(),
        }
    }

    // .daml_lf_1.BuiltinFunction builtin = 3;

    pub fn clear_builtin(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_builtin(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::builtin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_builtin(&mut self, v: BuiltinFunction) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::builtin(v))
    }

    pub fn get_builtin(&self) -> BuiltinFunction {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::builtin(v)) => v,
            _ => BuiltinFunction::ADD_DECIMAL,
        }
    }

    // .daml_lf_1.PrimCon prim_con = 4;

    pub fn clear_prim_con(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_prim_con(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::prim_con(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prim_con(&mut self, v: PrimCon) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::prim_con(v))
    }

    pub fn get_prim_con(&self) -> PrimCon {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::prim_con(v)) => v,
            _ => PrimCon::CON_UNIT,
        }
    }

    // .daml_lf_1.PrimLit prim_lit = 5;

    pub fn clear_prim_lit(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_prim_lit(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::prim_lit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prim_lit(&mut self, v: PrimLit) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::prim_lit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prim_lit(&mut self) -> &mut PrimLit {
        if let ::std::option::Option::Some(Expr_oneof_Sum::prim_lit(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::prim_lit(PrimLit::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::prim_lit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prim_lit(&mut self) -> PrimLit {
        if self.has_prim_lit() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::prim_lit(v)) => v,
                _ => panic!(),
            }
        } else {
            PrimLit::new()
        }
    }

    pub fn get_prim_lit(&self) -> &PrimLit {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::prim_lit(ref v)) => v,
            _ => PrimLit::default_instance(),
        }
    }

    // .daml_lf_1.Expr.RecCon rec_con = 6;

    pub fn clear_rec_con(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_rec_con(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::rec_con(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rec_con(&mut self, v: Expr_RecCon) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::rec_con(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rec_con(&mut self) -> &mut Expr_RecCon {
        if let ::std::option::Option::Some(Expr_oneof_Sum::rec_con(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::rec_con(Expr_RecCon::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::rec_con(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rec_con(&mut self) -> Expr_RecCon {
        if self.has_rec_con() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::rec_con(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_RecCon::new()
        }
    }

    pub fn get_rec_con(&self) -> &Expr_RecCon {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::rec_con(ref v)) => v,
            _ => Expr_RecCon::default_instance(),
        }
    }

    // .daml_lf_1.Expr.RecProj rec_proj = 7;

    pub fn clear_rec_proj(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_rec_proj(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::rec_proj(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rec_proj(&mut self, v: Expr_RecProj) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::rec_proj(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rec_proj(&mut self) -> &mut Expr_RecProj {
        if let ::std::option::Option::Some(Expr_oneof_Sum::rec_proj(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::rec_proj(Expr_RecProj::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::rec_proj(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rec_proj(&mut self) -> Expr_RecProj {
        if self.has_rec_proj() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::rec_proj(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_RecProj::new()
        }
    }

    pub fn get_rec_proj(&self) -> &Expr_RecProj {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::rec_proj(ref v)) => v,
            _ => Expr_RecProj::default_instance(),
        }
    }

    // .daml_lf_1.Expr.VariantCon variant_con = 8;

    pub fn clear_variant_con(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_variant_con(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::variant_con(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_variant_con(&mut self, v: Expr_VariantCon) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::variant_con(v))
    }

    // Mutable pointer to the field.
    pub fn mut_variant_con(&mut self) -> &mut Expr_VariantCon {
        if let ::std::option::Option::Some(Expr_oneof_Sum::variant_con(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::variant_con(Expr_VariantCon::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::variant_con(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_variant_con(&mut self) -> Expr_VariantCon {
        if self.has_variant_con() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::variant_con(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_VariantCon::new()
        }
    }

    pub fn get_variant_con(&self) -> &Expr_VariantCon {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::variant_con(ref v)) => v,
            _ => Expr_VariantCon::default_instance(),
        }
    }

    // .daml_lf_1.Expr.TupleCon tuple_con = 9;

    pub fn clear_tuple_con(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_tuple_con(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::tuple_con(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tuple_con(&mut self, v: Expr_TupleCon) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::tuple_con(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tuple_con(&mut self) -> &mut Expr_TupleCon {
        if let ::std::option::Option::Some(Expr_oneof_Sum::tuple_con(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::tuple_con(Expr_TupleCon::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::tuple_con(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tuple_con(&mut self) -> Expr_TupleCon {
        if self.has_tuple_con() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::tuple_con(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_TupleCon::new()
        }
    }

    pub fn get_tuple_con(&self) -> &Expr_TupleCon {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::tuple_con(ref v)) => v,
            _ => Expr_TupleCon::default_instance(),
        }
    }

    // .daml_lf_1.Expr.TupleProj tuple_proj = 10;

    pub fn clear_tuple_proj(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_tuple_proj(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::tuple_proj(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tuple_proj(&mut self, v: Expr_TupleProj) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::tuple_proj(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tuple_proj(&mut self) -> &mut Expr_TupleProj {
        if let ::std::option::Option::Some(Expr_oneof_Sum::tuple_proj(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::tuple_proj(Expr_TupleProj::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::tuple_proj(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tuple_proj(&mut self) -> Expr_TupleProj {
        if self.has_tuple_proj() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::tuple_proj(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_TupleProj::new()
        }
    }

    pub fn get_tuple_proj(&self) -> &Expr_TupleProj {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::tuple_proj(ref v)) => v,
            _ => Expr_TupleProj::default_instance(),
        }
    }

    // .daml_lf_1.Expr.App app = 11;

    pub fn clear_app(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_app(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::app(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: Expr_App) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::app(v))
    }

    // Mutable pointer to the field.
    pub fn mut_app(&mut self) -> &mut Expr_App {
        if let ::std::option::Option::Some(Expr_oneof_Sum::app(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::app(Expr_App::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::app(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_app(&mut self) -> Expr_App {
        if self.has_app() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::app(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_App::new()
        }
    }

    pub fn get_app(&self) -> &Expr_App {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::app(ref v)) => v,
            _ => Expr_App::default_instance(),
        }
    }

    // .daml_lf_1.Expr.TyApp ty_app = 12;

    pub fn clear_ty_app(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_ty_app(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::ty_app(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ty_app(&mut self, v: Expr_TyApp) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::ty_app(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ty_app(&mut self) -> &mut Expr_TyApp {
        if let ::std::option::Option::Some(Expr_oneof_Sum::ty_app(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::ty_app(Expr_TyApp::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::ty_app(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ty_app(&mut self) -> Expr_TyApp {
        if self.has_ty_app() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::ty_app(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_TyApp::new()
        }
    }

    pub fn get_ty_app(&self) -> &Expr_TyApp {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::ty_app(ref v)) => v,
            _ => Expr_TyApp::default_instance(),
        }
    }

    // .daml_lf_1.Expr.Abs abs = 13;

    pub fn clear_abs(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_abs(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::abs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_abs(&mut self, v: Expr_Abs) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::abs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_abs(&mut self) -> &mut Expr_Abs {
        if let ::std::option::Option::Some(Expr_oneof_Sum::abs(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::abs(Expr_Abs::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::abs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_abs(&mut self) -> Expr_Abs {
        if self.has_abs() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::abs(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Abs::new()
        }
    }

    pub fn get_abs(&self) -> &Expr_Abs {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::abs(ref v)) => v,
            _ => Expr_Abs::default_instance(),
        }
    }

    // .daml_lf_1.Expr.TyAbs ty_abs = 14;

    pub fn clear_ty_abs(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_ty_abs(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::ty_abs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ty_abs(&mut self, v: Expr_TyAbs) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::ty_abs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ty_abs(&mut self) -> &mut Expr_TyAbs {
        if let ::std::option::Option::Some(Expr_oneof_Sum::ty_abs(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::ty_abs(Expr_TyAbs::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::ty_abs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ty_abs(&mut self) -> Expr_TyAbs {
        if self.has_ty_abs() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::ty_abs(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_TyAbs::new()
        }
    }

    pub fn get_ty_abs(&self) -> &Expr_TyAbs {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::ty_abs(ref v)) => v,
            _ => Expr_TyAbs::default_instance(),
        }
    }

    // .daml_lf_1.Case case = 15;

    pub fn clear_case(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_case(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::case(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_case(&mut self, v: Case) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::case(v))
    }

    // Mutable pointer to the field.
    pub fn mut_case(&mut self) -> &mut Case {
        if let ::std::option::Option::Some(Expr_oneof_Sum::case(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::case(Case::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::case(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_case(&mut self) -> Case {
        if self.has_case() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::case(v)) => v,
                _ => panic!(),
            }
        } else {
            Case::new()
        }
    }

    pub fn get_case(&self) -> &Case {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::case(ref v)) => v,
            _ => Case::default_instance(),
        }
    }

    // .daml_lf_1.Block let = 16;

    pub fn clear_field_let(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_field_let(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::field_let(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_let(&mut self, v: Block) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::field_let(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_let(&mut self) -> &mut Block {
        if let ::std::option::Option::Some(Expr_oneof_Sum::field_let(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::field_let(Block::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::field_let(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_let(&mut self) -> Block {
        if self.has_field_let() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::field_let(v)) => v,
                _ => panic!(),
            }
        } else {
            Block::new()
        }
    }

    pub fn get_field_let(&self) -> &Block {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::field_let(ref v)) => v,
            _ => Block::default_instance(),
        }
    }

    // .daml_lf_1.Expr.Nil nil = 17;

    pub fn clear_nil(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_nil(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::nil(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nil(&mut self, v: Expr_Nil) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::nil(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nil(&mut self) -> &mut Expr_Nil {
        if let ::std::option::Option::Some(Expr_oneof_Sum::nil(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::nil(Expr_Nil::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::nil(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nil(&mut self) -> Expr_Nil {
        if self.has_nil() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::nil(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Nil::new()
        }
    }

    pub fn get_nil(&self) -> &Expr_Nil {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::nil(ref v)) => v,
            _ => Expr_Nil::default_instance(),
        }
    }

    // .daml_lf_1.Expr.Cons cons = 18;

    pub fn clear_cons(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_cons(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::cons(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cons(&mut self, v: Expr_Cons) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::cons(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cons(&mut self) -> &mut Expr_Cons {
        if let ::std::option::Option::Some(Expr_oneof_Sum::cons(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::cons(Expr_Cons::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::cons(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cons(&mut self) -> Expr_Cons {
        if self.has_cons() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::cons(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_Cons::new()
        }
    }

    pub fn get_cons(&self) -> &Expr_Cons {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::cons(ref v)) => v,
            _ => Expr_Cons::default_instance(),
        }
    }

    // .daml_lf_1.Update update = 20;

    pub fn clear_update(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::update(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: Update) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::update(v))
    }

    // Mutable pointer to the field.
    pub fn mut_update(&mut self) -> &mut Update {
        if let ::std::option::Option::Some(Expr_oneof_Sum::update(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::update(Update::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::update(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_update(&mut self) -> Update {
        if self.has_update() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::update(v)) => v,
                _ => panic!(),
            }
        } else {
            Update::new()
        }
    }

    pub fn get_update(&self) -> &Update {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::update(ref v)) => v,
            _ => Update::default_instance(),
        }
    }

    // .daml_lf_1.Scenario scenario = 21;

    pub fn clear_scenario(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_scenario(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::scenario(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scenario(&mut self, v: Scenario) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::scenario(v))
    }

    // Mutable pointer to the field.
    pub fn mut_scenario(&mut self) -> &mut Scenario {
        if let ::std::option::Option::Some(Expr_oneof_Sum::scenario(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::scenario(Scenario::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::scenario(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_scenario(&mut self) -> Scenario {
        if self.has_scenario() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::scenario(v)) => v,
                _ => panic!(),
            }
        } else {
            Scenario::new()
        }
    }

    pub fn get_scenario(&self) -> &Scenario {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::scenario(ref v)) => v,
            _ => Scenario::default_instance(),
        }
    }

    // .daml_lf_1.Expr.RecUpd rec_upd = 22;

    pub fn clear_rec_upd(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_rec_upd(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::rec_upd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rec_upd(&mut self, v: Expr_RecUpd) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::rec_upd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rec_upd(&mut self) -> &mut Expr_RecUpd {
        if let ::std::option::Option::Some(Expr_oneof_Sum::rec_upd(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::rec_upd(Expr_RecUpd::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::rec_upd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rec_upd(&mut self) -> Expr_RecUpd {
        if self.has_rec_upd() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::rec_upd(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_RecUpd::new()
        }
    }

    pub fn get_rec_upd(&self) -> &Expr_RecUpd {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::rec_upd(ref v)) => v,
            _ => Expr_RecUpd::default_instance(),
        }
    }

    // .daml_lf_1.Expr.TupleUpd tuple_upd = 23;

    pub fn clear_tuple_upd(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_tuple_upd(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::tuple_upd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tuple_upd(&mut self, v: Expr_TupleUpd) {
        self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::tuple_upd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tuple_upd(&mut self) -> &mut Expr_TupleUpd {
        if let ::std::option::Option::Some(Expr_oneof_Sum::tuple_upd(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::tuple_upd(Expr_TupleUpd::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::tuple_upd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tuple_upd(&mut self) -> Expr_TupleUpd {
        if self.has_tuple_upd() {
            match self.Sum.take() {
                ::std::option::Option::Some(Expr_oneof_Sum::tuple_upd(v)) => v,
                _ => panic!(),
            }
        } else {
            Expr_TupleUpd::new()
        }
    }

    pub fn get_tuple_upd(&self) -> &Expr_TupleUpd {
        match self.Sum {
            ::std::option::Option::Some(Expr_oneof_Sum::tuple_upd(ref v)) => v,
            _ => Expr_TupleUpd::default_instance(),
        }
    }
}

impl ::protobuf::Message for Expr {
    fn is_initialized(&self) -> bool {
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Expr_oneof_Sum::val(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::prim_lit(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::rec_con(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::rec_proj(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::variant_con(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::tuple_con(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::tuple_proj(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::app(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::ty_app(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::abs(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::ty_abs(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::case(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::field_let(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::nil(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::cons(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::update(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::scenario(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::rec_upd(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Expr_oneof_Sum::tuple_upd(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::var(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::val(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::builtin(is.read_enum()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::prim_con(is.read_enum()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::prim_lit(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::rec_con(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::rec_proj(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::variant_con(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::tuple_con(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::tuple_proj(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::app(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::ty_app(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::abs(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::ty_abs(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::case(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::field_let(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::nil(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::cons(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::update(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::scenario(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::rec_upd(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Expr_oneof_Sum::tuple_upd(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Expr_oneof_Sum::var(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &Expr_oneof_Sum::val(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::builtin(v) => {
                    my_size += ::protobuf::rt::enum_size(3, v);
                },
                &Expr_oneof_Sum::prim_con(v) => {
                    my_size += ::protobuf::rt::enum_size(4, v);
                },
                &Expr_oneof_Sum::prim_lit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::rec_con(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::rec_proj(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::variant_con(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::tuple_con(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::tuple_proj(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::app(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::ty_app(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::abs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::ty_abs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::case(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::field_let(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::nil(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::cons(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::update(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::scenario(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::rec_upd(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Expr_oneof_Sum::tuple_upd(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Expr_oneof_Sum::var(ref v) => {
                    os.write_string(1, v)?;
                },
                &Expr_oneof_Sum::val(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::builtin(v) => {
                    os.write_enum(3, v.value())?;
                },
                &Expr_oneof_Sum::prim_con(v) => {
                    os.write_enum(4, v.value())?;
                },
                &Expr_oneof_Sum::prim_lit(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::rec_con(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::rec_proj(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::variant_con(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::tuple_con(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::tuple_proj(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::app(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::ty_app(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::abs(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::ty_abs(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::case(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::field_let(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::nil(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::cons(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::update(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::scenario(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::rec_upd(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Expr_oneof_Sum::tuple_upd(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr {
        Expr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Location>>(
                    "location",
                    |m: &Expr| { &m.location },
                    |m: &mut Expr| { &mut m.location },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "var",
                    Expr::has_var,
                    Expr::get_var,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ValName>(
                    "val",
                    Expr::has_val,
                    Expr::get_val,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, BuiltinFunction>(
                    "builtin",
                    Expr::has_builtin,
                    Expr::get_builtin,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, PrimCon>(
                    "prim_con",
                    Expr::has_prim_con,
                    Expr::get_prim_con,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PrimLit>(
                    "prim_lit",
                    Expr::has_prim_lit,
                    Expr::get_prim_lit,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_RecCon>(
                    "rec_con",
                    Expr::has_rec_con,
                    Expr::get_rec_con,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_RecProj>(
                    "rec_proj",
                    Expr::has_rec_proj,
                    Expr::get_rec_proj,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_VariantCon>(
                    "variant_con",
                    Expr::has_variant_con,
                    Expr::get_variant_con,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_TupleCon>(
                    "tuple_con",
                    Expr::has_tuple_con,
                    Expr::get_tuple_con,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_TupleProj>(
                    "tuple_proj",
                    Expr::has_tuple_proj,
                    Expr::get_tuple_proj,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_App>(
                    "app",
                    Expr::has_app,
                    Expr::get_app,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_TyApp>(
                    "ty_app",
                    Expr::has_ty_app,
                    Expr::get_ty_app,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Abs>(
                    "abs",
                    Expr::has_abs,
                    Expr::get_abs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_TyAbs>(
                    "ty_abs",
                    Expr::has_ty_abs,
                    Expr::get_ty_abs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Case>(
                    "case",
                    Expr::has_case,
                    Expr::get_case,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Block>(
                    "let",
                    Expr::has_field_let,
                    Expr::get_field_let,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Nil>(
                    "nil",
                    Expr::has_nil,
                    Expr::get_nil,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_Cons>(
                    "cons",
                    Expr::has_cons,
                    Expr::get_cons,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Update>(
                    "update",
                    Expr::has_update,
                    Expr::get_update,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Scenario>(
                    "scenario",
                    Expr::has_scenario,
                    Expr::get_scenario,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_RecUpd>(
                    "rec_upd",
                    Expr::has_rec_upd,
                    Expr::get_rec_upd,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Expr_TupleUpd>(
                    "tuple_upd",
                    Expr::has_tuple_upd,
                    Expr::get_tuple_upd,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr>(
                    "Expr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr {
        static mut instance: ::protobuf::lazy::Lazy<Expr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr,
        };
        unsafe {
            instance.get(Expr::new)
        }
    }
}

impl ::protobuf::Clear for Expr {
    fn clear(&mut self) {
        self.clear_location();
        self.clear_var();
        self.clear_val();
        self.clear_builtin();
        self.clear_prim_con();
        self.clear_prim_lit();
        self.clear_rec_con();
        self.clear_rec_proj();
        self.clear_variant_con();
        self.clear_tuple_con();
        self.clear_tuple_proj();
        self.clear_app();
        self.clear_ty_app();
        self.clear_abs();
        self.clear_ty_abs();
        self.clear_case();
        self.clear_field_let();
        self.clear_nil();
        self.clear_cons();
        self.clear_update();
        self.clear_scenario();
        self.clear_rec_upd();
        self.clear_tuple_upd();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_RecCon {
    // message fields
    pub tycon: ::protobuf::SingularPtrField<Type_Con>,
    pub fields: ::protobuf::RepeatedField<FieldWithExpr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_RecCon {
    pub fn new() -> Expr_RecCon {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type.Con tycon = 1;

    pub fn clear_tycon(&mut self) {
        self.tycon.clear();
    }

    pub fn has_tycon(&self) -> bool {
        self.tycon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tycon(&mut self, v: Type_Con) {
        self.tycon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tycon(&mut self) -> &mut Type_Con {
        if self.tycon.is_none() {
            self.tycon.set_default();
        }
        self.tycon.as_mut().unwrap()
    }

    // Take field
    pub fn take_tycon(&mut self) -> Type_Con {
        self.tycon.take().unwrap_or_else(|| Type_Con::new())
    }

    pub fn get_tycon(&self) -> &Type_Con {
        self.tycon.as_ref().unwrap_or_else(|| Type_Con::default_instance())
    }

    // repeated .daml_lf_1.FieldWithExpr fields = 2;

    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<FieldWithExpr>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<FieldWithExpr> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<FieldWithExpr> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }

    pub fn get_fields(&self) -> &[FieldWithExpr] {
        &self.fields
    }
}

impl ::protobuf::Message for Expr_RecCon {
    fn is_initialized(&self) -> bool {
        for v in &self.tycon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tycon)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tycon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tycon.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.fields {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_RecCon {
        Expr_RecCon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type_Con>>(
                    "tycon",
                    |m: &Expr_RecCon| { &m.tycon },
                    |m: &mut Expr_RecCon| { &mut m.tycon },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldWithExpr>>(
                    "fields",
                    |m: &Expr_RecCon| { &m.fields },
                    |m: &mut Expr_RecCon| { &mut m.fields },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_RecCon>(
                    "Expr_RecCon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_RecCon {
        static mut instance: ::protobuf::lazy::Lazy<Expr_RecCon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_RecCon,
        };
        unsafe {
            instance.get(Expr_RecCon::new)
        }
    }
}

impl ::protobuf::Clear for Expr_RecCon {
    fn clear(&mut self) {
        self.clear_tycon();
        self.clear_fields();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_RecCon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_RecCon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_RecProj {
    // message fields
    pub tycon: ::protobuf::SingularPtrField<Type_Con>,
    pub field: ::std::string::String,
    pub record: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_RecProj {
    pub fn new() -> Expr_RecProj {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type.Con tycon = 1;

    pub fn clear_tycon(&mut self) {
        self.tycon.clear();
    }

    pub fn has_tycon(&self) -> bool {
        self.tycon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tycon(&mut self, v: Type_Con) {
        self.tycon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tycon(&mut self) -> &mut Type_Con {
        if self.tycon.is_none() {
            self.tycon.set_default();
        }
        self.tycon.as_mut().unwrap()
    }

    // Take field
    pub fn take_tycon(&mut self) -> Type_Con {
        self.tycon.take().unwrap_or_else(|| Type_Con::new())
    }

    pub fn get_tycon(&self) -> &Type_Con {
        self.tycon.as_ref().unwrap_or_else(|| Type_Con::default_instance())
    }

    // string field = 2;

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    pub fn get_field(&self) -> &str {
        &self.field
    }

    // .daml_lf_1.Expr record = 3;

    pub fn clear_record(&mut self) {
        self.record.clear();
    }

    pub fn has_record(&self) -> bool {
        self.record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record(&mut self, v: Expr) {
        self.record = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_record(&mut self) -> &mut Expr {
        if self.record.is_none() {
            self.record.set_default();
        }
        self.record.as_mut().unwrap()
    }

    // Take field
    pub fn take_record(&mut self) -> Expr {
        self.record.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_record(&self) -> &Expr {
        self.record.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Expr_RecProj {
    fn is_initialized(&self) -> bool {
        for v in &self.tycon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.record {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tycon)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.record)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tycon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field);
        }
        if let Some(ref v) = self.record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tycon.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.field.is_empty() {
            os.write_string(2, &self.field)?;
        }
        if let Some(ref v) = self.record.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_RecProj {
        Expr_RecProj::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type_Con>>(
                    "tycon",
                    |m: &Expr_RecProj| { &m.tycon },
                    |m: &mut Expr_RecProj| { &mut m.tycon },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field",
                    |m: &Expr_RecProj| { &m.field },
                    |m: &mut Expr_RecProj| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "record",
                    |m: &Expr_RecProj| { &m.record },
                    |m: &mut Expr_RecProj| { &mut m.record },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_RecProj>(
                    "Expr_RecProj",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_RecProj {
        static mut instance: ::protobuf::lazy::Lazy<Expr_RecProj> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_RecProj,
        };
        unsafe {
            instance.get(Expr_RecProj::new)
        }
    }
}

impl ::protobuf::Clear for Expr_RecProj {
    fn clear(&mut self) {
        self.clear_tycon();
        self.clear_field();
        self.clear_record();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_RecProj {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_RecProj {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_RecUpd {
    // message fields
    pub tycon: ::protobuf::SingularPtrField<Type_Con>,
    pub field: ::std::string::String,
    pub record: ::protobuf::SingularPtrField<Expr>,
    pub update: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_RecUpd {
    pub fn new() -> Expr_RecUpd {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type.Con tycon = 1;

    pub fn clear_tycon(&mut self) {
        self.tycon.clear();
    }

    pub fn has_tycon(&self) -> bool {
        self.tycon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tycon(&mut self, v: Type_Con) {
        self.tycon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tycon(&mut self) -> &mut Type_Con {
        if self.tycon.is_none() {
            self.tycon.set_default();
        }
        self.tycon.as_mut().unwrap()
    }

    // Take field
    pub fn take_tycon(&mut self) -> Type_Con {
        self.tycon.take().unwrap_or_else(|| Type_Con::new())
    }

    pub fn get_tycon(&self) -> &Type_Con {
        self.tycon.as_ref().unwrap_or_else(|| Type_Con::default_instance())
    }

    // string field = 2;

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    pub fn get_field(&self) -> &str {
        &self.field
    }

    // .daml_lf_1.Expr record = 3;

    pub fn clear_record(&mut self) {
        self.record.clear();
    }

    pub fn has_record(&self) -> bool {
        self.record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record(&mut self, v: Expr) {
        self.record = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_record(&mut self) -> &mut Expr {
        if self.record.is_none() {
            self.record.set_default();
        }
        self.record.as_mut().unwrap()
    }

    // Take field
    pub fn take_record(&mut self) -> Expr {
        self.record.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_record(&self) -> &Expr {
        self.record.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.Expr update = 4;

    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: Expr) {
        self.update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut Expr {
        if self.update.is_none() {
            self.update.set_default();
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> Expr {
        self.update.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_update(&self) -> &Expr {
        self.update.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Expr_RecUpd {
    fn is_initialized(&self) -> bool {
        for v in &self.tycon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.record {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tycon)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.record)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tycon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field);
        }
        if let Some(ref v) = self.record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tycon.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.field.is_empty() {
            os.write_string(2, &self.field)?;
        }
        if let Some(ref v) = self.record.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_RecUpd {
        Expr_RecUpd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type_Con>>(
                    "tycon",
                    |m: &Expr_RecUpd| { &m.tycon },
                    |m: &mut Expr_RecUpd| { &mut m.tycon },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field",
                    |m: &Expr_RecUpd| { &m.field },
                    |m: &mut Expr_RecUpd| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "record",
                    |m: &Expr_RecUpd| { &m.record },
                    |m: &mut Expr_RecUpd| { &mut m.record },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "update",
                    |m: &Expr_RecUpd| { &m.update },
                    |m: &mut Expr_RecUpd| { &mut m.update },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_RecUpd>(
                    "Expr_RecUpd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_RecUpd {
        static mut instance: ::protobuf::lazy::Lazy<Expr_RecUpd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_RecUpd,
        };
        unsafe {
            instance.get(Expr_RecUpd::new)
        }
    }
}

impl ::protobuf::Clear for Expr_RecUpd {
    fn clear(&mut self) {
        self.clear_tycon();
        self.clear_field();
        self.clear_record();
        self.clear_update();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_RecUpd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_RecUpd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_VariantCon {
    // message fields
    pub tycon: ::protobuf::SingularPtrField<Type_Con>,
    pub variant_con: ::std::string::String,
    pub variant_arg: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_VariantCon {
    pub fn new() -> Expr_VariantCon {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type.Con tycon = 1;

    pub fn clear_tycon(&mut self) {
        self.tycon.clear();
    }

    pub fn has_tycon(&self) -> bool {
        self.tycon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tycon(&mut self, v: Type_Con) {
        self.tycon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tycon(&mut self) -> &mut Type_Con {
        if self.tycon.is_none() {
            self.tycon.set_default();
        }
        self.tycon.as_mut().unwrap()
    }

    // Take field
    pub fn take_tycon(&mut self) -> Type_Con {
        self.tycon.take().unwrap_or_else(|| Type_Con::new())
    }

    pub fn get_tycon(&self) -> &Type_Con {
        self.tycon.as_ref().unwrap_or_else(|| Type_Con::default_instance())
    }

    // string variant_con = 2;

    pub fn clear_variant_con(&mut self) {
        self.variant_con.clear();
    }

    // Param is passed by value, moved
    pub fn set_variant_con(&mut self, v: ::std::string::String) {
        self.variant_con = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_variant_con(&mut self) -> &mut ::std::string::String {
        &mut self.variant_con
    }

    // Take field
    pub fn take_variant_con(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.variant_con, ::std::string::String::new())
    }

    pub fn get_variant_con(&self) -> &str {
        &self.variant_con
    }

    // .daml_lf_1.Expr variant_arg = 3;

    pub fn clear_variant_arg(&mut self) {
        self.variant_arg.clear();
    }

    pub fn has_variant_arg(&self) -> bool {
        self.variant_arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_variant_arg(&mut self, v: Expr) {
        self.variant_arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_variant_arg(&mut self) -> &mut Expr {
        if self.variant_arg.is_none() {
            self.variant_arg.set_default();
        }
        self.variant_arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_variant_arg(&mut self) -> Expr {
        self.variant_arg.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_variant_arg(&self) -> &Expr {
        self.variant_arg.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Expr_VariantCon {
    fn is_initialized(&self) -> bool {
        for v in &self.tycon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variant_arg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tycon)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.variant_con)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.variant_arg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tycon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.variant_con.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.variant_con);
        }
        if let Some(ref v) = self.variant_arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tycon.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.variant_con.is_empty() {
            os.write_string(2, &self.variant_con)?;
        }
        if let Some(ref v) = self.variant_arg.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_VariantCon {
        Expr_VariantCon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type_Con>>(
                    "tycon",
                    |m: &Expr_VariantCon| { &m.tycon },
                    |m: &mut Expr_VariantCon| { &mut m.tycon },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "variant_con",
                    |m: &Expr_VariantCon| { &m.variant_con },
                    |m: &mut Expr_VariantCon| { &mut m.variant_con },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "variant_arg",
                    |m: &Expr_VariantCon| { &m.variant_arg },
                    |m: &mut Expr_VariantCon| { &mut m.variant_arg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_VariantCon>(
                    "Expr_VariantCon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_VariantCon {
        static mut instance: ::protobuf::lazy::Lazy<Expr_VariantCon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_VariantCon,
        };
        unsafe {
            instance.get(Expr_VariantCon::new)
        }
    }
}

impl ::protobuf::Clear for Expr_VariantCon {
    fn clear(&mut self) {
        self.clear_tycon();
        self.clear_variant_con();
        self.clear_variant_arg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_VariantCon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_VariantCon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_TupleCon {
    // message fields
    pub fields: ::protobuf::RepeatedField<FieldWithExpr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_TupleCon {
    pub fn new() -> Expr_TupleCon {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.FieldWithExpr fields = 1;

    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<FieldWithExpr>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<FieldWithExpr> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<FieldWithExpr> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }

    pub fn get_fields(&self) -> &[FieldWithExpr] {
        &self.fields
    }
}

impl ::protobuf::Message for Expr_TupleCon {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_TupleCon {
        Expr_TupleCon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldWithExpr>>(
                    "fields",
                    |m: &Expr_TupleCon| { &m.fields },
                    |m: &mut Expr_TupleCon| { &mut m.fields },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_TupleCon>(
                    "Expr_TupleCon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_TupleCon {
        static mut instance: ::protobuf::lazy::Lazy<Expr_TupleCon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_TupleCon,
        };
        unsafe {
            instance.get(Expr_TupleCon::new)
        }
    }
}

impl ::protobuf::Clear for Expr_TupleCon {
    fn clear(&mut self) {
        self.clear_fields();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_TupleCon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_TupleCon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_TupleProj {
    // message fields
    pub field: ::std::string::String,
    pub tuple: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_TupleProj {
    pub fn new() -> Expr_TupleProj {
        ::std::default::Default::default()
    }

    // string field = 1;

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    pub fn get_field(&self) -> &str {
        &self.field
    }

    // .daml_lf_1.Expr tuple = 2;

    pub fn clear_tuple(&mut self) {
        self.tuple.clear();
    }

    pub fn has_tuple(&self) -> bool {
        self.tuple.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tuple(&mut self, v: Expr) {
        self.tuple = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tuple(&mut self) -> &mut Expr {
        if self.tuple.is_none() {
            self.tuple.set_default();
        }
        self.tuple.as_mut().unwrap()
    }

    // Take field
    pub fn take_tuple(&mut self) -> Expr {
        self.tuple.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_tuple(&self) -> &Expr {
        self.tuple.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Expr_TupleProj {
    fn is_initialized(&self) -> bool {
        for v in &self.tuple {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tuple)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field);
        }
        if let Some(ref v) = self.tuple.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.field.is_empty() {
            os.write_string(1, &self.field)?;
        }
        if let Some(ref v) = self.tuple.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_TupleProj {
        Expr_TupleProj::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field",
                    |m: &Expr_TupleProj| { &m.field },
                    |m: &mut Expr_TupleProj| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "tuple",
                    |m: &Expr_TupleProj| { &m.tuple },
                    |m: &mut Expr_TupleProj| { &mut m.tuple },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_TupleProj>(
                    "Expr_TupleProj",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_TupleProj {
        static mut instance: ::protobuf::lazy::Lazy<Expr_TupleProj> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_TupleProj,
        };
        unsafe {
            instance.get(Expr_TupleProj::new)
        }
    }
}

impl ::protobuf::Clear for Expr_TupleProj {
    fn clear(&mut self) {
        self.clear_field();
        self.clear_tuple();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_TupleProj {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_TupleProj {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_TupleUpd {
    // message fields
    pub field: ::std::string::String,
    pub tuple: ::protobuf::SingularPtrField<Expr>,
    pub update: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_TupleUpd {
    pub fn new() -> Expr_TupleUpd {
        ::std::default::Default::default()
    }

    // string field = 1;

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field, ::std::string::String::new())
    }

    pub fn get_field(&self) -> &str {
        &self.field
    }

    // .daml_lf_1.Expr tuple = 2;

    pub fn clear_tuple(&mut self) {
        self.tuple.clear();
    }

    pub fn has_tuple(&self) -> bool {
        self.tuple.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tuple(&mut self, v: Expr) {
        self.tuple = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tuple(&mut self) -> &mut Expr {
        if self.tuple.is_none() {
            self.tuple.set_default();
        }
        self.tuple.as_mut().unwrap()
    }

    // Take field
    pub fn take_tuple(&mut self) -> Expr {
        self.tuple.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_tuple(&self) -> &Expr {
        self.tuple.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.Expr update = 3;

    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: Expr) {
        self.update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut Expr {
        if self.update.is_none() {
            self.update.set_default();
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> Expr {
        self.update.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_update(&self) -> &Expr {
        self.update.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Expr_TupleUpd {
    fn is_initialized(&self) -> bool {
        for v in &self.tuple {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tuple)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field);
        }
        if let Some(ref v) = self.tuple.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.field.is_empty() {
            os.write_string(1, &self.field)?;
        }
        if let Some(ref v) = self.tuple.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_TupleUpd {
        Expr_TupleUpd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field",
                    |m: &Expr_TupleUpd| { &m.field },
                    |m: &mut Expr_TupleUpd| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "tuple",
                    |m: &Expr_TupleUpd| { &m.tuple },
                    |m: &mut Expr_TupleUpd| { &mut m.tuple },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "update",
                    |m: &Expr_TupleUpd| { &m.update },
                    |m: &mut Expr_TupleUpd| { &mut m.update },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_TupleUpd>(
                    "Expr_TupleUpd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_TupleUpd {
        static mut instance: ::protobuf::lazy::Lazy<Expr_TupleUpd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_TupleUpd,
        };
        unsafe {
            instance.get(Expr_TupleUpd::new)
        }
    }
}

impl ::protobuf::Clear for Expr_TupleUpd {
    fn clear(&mut self) {
        self.clear_field();
        self.clear_tuple();
        self.clear_update();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_TupleUpd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_TupleUpd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_App {
    // message fields
    pub fun: ::protobuf::SingularPtrField<Expr>,
    pub args: ::protobuf::RepeatedField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_App {
    pub fn new() -> Expr_App {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Expr fun = 1;

    pub fn clear_fun(&mut self) {
        self.fun.clear();
    }

    pub fn has_fun(&self) -> bool {
        self.fun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fun(&mut self, v: Expr) {
        self.fun = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fun(&mut self) -> &mut Expr {
        if self.fun.is_none() {
            self.fun.set_default();
        }
        self.fun.as_mut().unwrap()
    }

    // Take field
    pub fn take_fun(&mut self) -> Expr {
        self.fun.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_fun(&self) -> &Expr {
        self.fun.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // repeated .daml_lf_1.Expr args = 2;

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<Expr>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<Expr> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<Expr> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    pub fn get_args(&self) -> &[Expr] {
        &self.args
    }
}

impl ::protobuf::Message for Expr_App {
    fn is_initialized(&self) -> bool {
        for v in &self.fun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fun)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fun.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.args {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_App {
        Expr_App::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "fun",
                    |m: &Expr_App| { &m.fun },
                    |m: &mut Expr_App| { &mut m.fun },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "args",
                    |m: &Expr_App| { &m.args },
                    |m: &mut Expr_App| { &mut m.args },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_App>(
                    "Expr_App",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_App {
        static mut instance: ::protobuf::lazy::Lazy<Expr_App> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_App,
        };
        unsafe {
            instance.get(Expr_App::new)
        }
    }
}

impl ::protobuf::Clear for Expr_App {
    fn clear(&mut self) {
        self.clear_fun();
        self.clear_args();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_App {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_TyApp {
    // message fields
    pub expr: ::protobuf::SingularPtrField<Expr>,
    pub types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_TyApp {
    pub fn new() -> Expr_TyApp {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Expr expr = 1;

    pub fn clear_expr(&mut self) {
        self.expr.clear();
    }

    pub fn has_expr(&self) -> bool {
        self.expr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expr(&mut self, v: Expr) {
        self.expr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expr(&mut self) -> &mut Expr {
        if self.expr.is_none() {
            self.expr.set_default();
        }
        self.expr.as_mut().unwrap()
    }

    // Take field
    pub fn take_expr(&mut self) -> Expr {
        self.expr.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_expr(&self) -> &Expr {
        self.expr.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // repeated .daml_lf_1.Type types = 2;

    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.types, ::protobuf::RepeatedField::new())
    }

    pub fn get_types(&self) -> &[Type] {
        &self.types
    }
}

impl ::protobuf::Message for Expr_TyApp {
    fn is_initialized(&self) -> bool {
        for v in &self.expr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expr)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.expr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.expr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.types {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_TyApp {
        Expr_TyApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "expr",
                    |m: &Expr_TyApp| { &m.expr },
                    |m: &mut Expr_TyApp| { &mut m.expr },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "types",
                    |m: &Expr_TyApp| { &m.types },
                    |m: &mut Expr_TyApp| { &mut m.types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_TyApp>(
                    "Expr_TyApp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_TyApp {
        static mut instance: ::protobuf::lazy::Lazy<Expr_TyApp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_TyApp,
        };
        unsafe {
            instance.get(Expr_TyApp::new)
        }
    }
}

impl ::protobuf::Clear for Expr_TyApp {
    fn clear(&mut self) {
        self.clear_expr();
        self.clear_types();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_TyApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_TyApp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Abs {
    // message fields
    pub param: ::protobuf::RepeatedField<VarWithType>,
    pub body: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_Abs {
    pub fn new() -> Expr_Abs {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.VarWithType param = 1;

    pub fn clear_param(&mut self) {
        self.param.clear();
    }

    // Param is passed by value, moved
    pub fn set_param(&mut self, v: ::protobuf::RepeatedField<VarWithType>) {
        self.param = v;
    }

    // Mutable pointer to the field.
    pub fn mut_param(&mut self) -> &mut ::protobuf::RepeatedField<VarWithType> {
        &mut self.param
    }

    // Take field
    pub fn take_param(&mut self) -> ::protobuf::RepeatedField<VarWithType> {
        ::std::mem::replace(&mut self.param, ::protobuf::RepeatedField::new())
    }

    pub fn get_param(&self) -> &[VarWithType] {
        &self.param
    }

    // .daml_lf_1.Expr body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Expr) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Expr {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Expr {
        self.body.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_body(&self) -> &Expr {
        self.body.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Expr_Abs {
    fn is_initialized(&self) -> bool {
        for v in &self.param {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.param)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.param {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.param {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Abs {
        Expr_Abs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VarWithType>>(
                    "param",
                    |m: &Expr_Abs| { &m.param },
                    |m: &mut Expr_Abs| { &mut m.param },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "body",
                    |m: &Expr_Abs| { &m.body },
                    |m: &mut Expr_Abs| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Abs>(
                    "Expr_Abs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Abs {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Abs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Abs,
        };
        unsafe {
            instance.get(Expr_Abs::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Abs {
    fn clear(&mut self) {
        self.clear_param();
        self.clear_body();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Abs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Abs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_TyAbs {
    // message fields
    pub param: ::protobuf::RepeatedField<TypeVarWithKind>,
    pub body: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_TyAbs {
    pub fn new() -> Expr_TyAbs {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.TypeVarWithKind param = 1;

    pub fn clear_param(&mut self) {
        self.param.clear();
    }

    // Param is passed by value, moved
    pub fn set_param(&mut self, v: ::protobuf::RepeatedField<TypeVarWithKind>) {
        self.param = v;
    }

    // Mutable pointer to the field.
    pub fn mut_param(&mut self) -> &mut ::protobuf::RepeatedField<TypeVarWithKind> {
        &mut self.param
    }

    // Take field
    pub fn take_param(&mut self) -> ::protobuf::RepeatedField<TypeVarWithKind> {
        ::std::mem::replace(&mut self.param, ::protobuf::RepeatedField::new())
    }

    pub fn get_param(&self) -> &[TypeVarWithKind] {
        &self.param
    }

    // .daml_lf_1.Expr body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Expr) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Expr {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Expr {
        self.body.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_body(&self) -> &Expr {
        self.body.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Expr_TyAbs {
    fn is_initialized(&self) -> bool {
        for v in &self.param {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.param)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.param {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.param {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_TyAbs {
        Expr_TyAbs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeVarWithKind>>(
                    "param",
                    |m: &Expr_TyAbs| { &m.param },
                    |m: &mut Expr_TyAbs| { &mut m.param },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "body",
                    |m: &Expr_TyAbs| { &m.body },
                    |m: &mut Expr_TyAbs| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_TyAbs>(
                    "Expr_TyAbs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_TyAbs {
        static mut instance: ::protobuf::lazy::Lazy<Expr_TyAbs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_TyAbs,
        };
        unsafe {
            instance.get(Expr_TyAbs::new)
        }
    }
}

impl ::protobuf::Clear for Expr_TyAbs {
    fn clear(&mut self) {
        self.clear_param();
        self.clear_body();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_TyAbs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_TyAbs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Nil {
    // message fields
    pub field_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_Nil {
    pub fn new() -> Expr_Nil {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
}

impl ::protobuf::Message for Expr_Nil {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Nil {
        Expr_Nil::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &Expr_Nil| { &m.field_type },
                    |m: &mut Expr_Nil| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Nil>(
                    "Expr_Nil",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Nil {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Nil> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Nil,
        };
        unsafe {
            instance.get(Expr_Nil::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Nil {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Nil {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Nil {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Expr_Cons {
    // message fields
    pub field_type: ::protobuf::SingularPtrField<Type>,
    pub front: ::protobuf::RepeatedField<Expr>,
    pub tail: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Expr_Cons {
    pub fn new() -> Expr_Cons {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }

    // repeated .daml_lf_1.Expr front = 2;

    pub fn clear_front(&mut self) {
        self.front.clear();
    }

    // Param is passed by value, moved
    pub fn set_front(&mut self, v: ::protobuf::RepeatedField<Expr>) {
        self.front = v;
    }

    // Mutable pointer to the field.
    pub fn mut_front(&mut self) -> &mut ::protobuf::RepeatedField<Expr> {
        &mut self.front
    }

    // Take field
    pub fn take_front(&mut self) -> ::protobuf::RepeatedField<Expr> {
        ::std::mem::replace(&mut self.front, ::protobuf::RepeatedField::new())
    }

    pub fn get_front(&self) -> &[Expr] {
        &self.front
    }

    // .daml_lf_1.Expr tail = 3;

    pub fn clear_tail(&mut self) {
        self.tail.clear();
    }

    pub fn has_tail(&self) -> bool {
        self.tail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tail(&mut self, v: Expr) {
        self.tail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tail(&mut self) -> &mut Expr {
        if self.tail.is_none() {
            self.tail.set_default();
        }
        self.tail.as_mut().unwrap()
    }

    // Take field
    pub fn take_tail(&mut self) -> Expr {
        self.tail.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_tail(&self) -> &Expr {
        self.tail.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Expr_Cons {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.front {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.front)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.front {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.tail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.front {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.tail.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Expr_Cons {
        Expr_Cons::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &Expr_Cons| { &m.field_type },
                    |m: &mut Expr_Cons| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "front",
                    |m: &Expr_Cons| { &m.front },
                    |m: &mut Expr_Cons| { &mut m.front },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "tail",
                    |m: &Expr_Cons| { &m.tail },
                    |m: &mut Expr_Cons| { &mut m.tail },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Expr_Cons>(
                    "Expr_Cons",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Expr_Cons {
        static mut instance: ::protobuf::lazy::Lazy<Expr_Cons> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Expr_Cons,
        };
        unsafe {
            instance.get(Expr_Cons::new)
        }
    }
}

impl ::protobuf::Clear for Expr_Cons {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_front();
        self.clear_tail();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Expr_Cons {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Expr_Cons {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CaseAlt {
    // message fields
    pub body: ::protobuf::SingularPtrField<Expr>,
    // message oneof groups
    pub Sum: ::std::option::Option<CaseAlt_oneof_Sum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum CaseAlt_oneof_Sum {
    default(Unit),
    variant(CaseAlt_Variant),
    prim_con(PrimCon),
    nil(Unit),
    cons(CaseAlt_Cons),
}

impl CaseAlt {
    pub fn new() -> CaseAlt {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Unit default = 1;

    pub fn clear_default(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_default(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::default(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_default(&mut self, v: Unit) {
        self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::default(v))
    }

    // Mutable pointer to the field.
    pub fn mut_default(&mut self) -> &mut Unit {
        if let ::std::option::Option::Some(CaseAlt_oneof_Sum::default(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::default(Unit::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::default(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_default(&mut self) -> Unit {
        if self.has_default() {
            match self.Sum.take() {
                ::std::option::Option::Some(CaseAlt_oneof_Sum::default(v)) => v,
                _ => panic!(),
            }
        } else {
            Unit::new()
        }
    }

    pub fn get_default(&self) -> &Unit {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::default(ref v)) => v,
            _ => Unit::default_instance(),
        }
    }

    // .daml_lf_1.CaseAlt.Variant variant = 2;

    pub fn clear_variant(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_variant(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::variant(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_variant(&mut self, v: CaseAlt_Variant) {
        self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::variant(v))
    }

    // Mutable pointer to the field.
    pub fn mut_variant(&mut self) -> &mut CaseAlt_Variant {
        if let ::std::option::Option::Some(CaseAlt_oneof_Sum::variant(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::variant(CaseAlt_Variant::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::variant(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_variant(&mut self) -> CaseAlt_Variant {
        if self.has_variant() {
            match self.Sum.take() {
                ::std::option::Option::Some(CaseAlt_oneof_Sum::variant(v)) => v,
                _ => panic!(),
            }
        } else {
            CaseAlt_Variant::new()
        }
    }

    pub fn get_variant(&self) -> &CaseAlt_Variant {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::variant(ref v)) => v,
            _ => CaseAlt_Variant::default_instance(),
        }
    }

    // .daml_lf_1.PrimCon prim_con = 3;

    pub fn clear_prim_con(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_prim_con(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::prim_con(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prim_con(&mut self, v: PrimCon) {
        self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::prim_con(v))
    }

    pub fn get_prim_con(&self) -> PrimCon {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::prim_con(v)) => v,
            _ => PrimCon::CON_UNIT,
        }
    }

    // .daml_lf_1.Unit nil = 4;

    pub fn clear_nil(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_nil(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::nil(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nil(&mut self, v: Unit) {
        self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::nil(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nil(&mut self) -> &mut Unit {
        if let ::std::option::Option::Some(CaseAlt_oneof_Sum::nil(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::nil(Unit::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::nil(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nil(&mut self) -> Unit {
        if self.has_nil() {
            match self.Sum.take() {
                ::std::option::Option::Some(CaseAlt_oneof_Sum::nil(v)) => v,
                _ => panic!(),
            }
        } else {
            Unit::new()
        }
    }

    pub fn get_nil(&self) -> &Unit {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::nil(ref v)) => v,
            _ => Unit::default_instance(),
        }
    }

    // .daml_lf_1.CaseAlt.Cons cons = 5;

    pub fn clear_cons(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_cons(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::cons(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cons(&mut self, v: CaseAlt_Cons) {
        self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::cons(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cons(&mut self) -> &mut CaseAlt_Cons {
        if let ::std::option::Option::Some(CaseAlt_oneof_Sum::cons(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::cons(CaseAlt_Cons::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::cons(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cons(&mut self) -> CaseAlt_Cons {
        if self.has_cons() {
            match self.Sum.take() {
                ::std::option::Option::Some(CaseAlt_oneof_Sum::cons(v)) => v,
                _ => panic!(),
            }
        } else {
            CaseAlt_Cons::new()
        }
    }

    pub fn get_cons(&self) -> &CaseAlt_Cons {
        match self.Sum {
            ::std::option::Option::Some(CaseAlt_oneof_Sum::cons(ref v)) => v,
            _ => CaseAlt_Cons::default_instance(),
        }
    }

    // .daml_lf_1.Expr body = 6;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Expr) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Expr {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Expr {
        self.body.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_body(&self) -> &Expr {
        self.body.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for CaseAlt {
    fn is_initialized(&self) -> bool {
        if let Some(CaseAlt_oneof_Sum::default(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CaseAlt_oneof_Sum::variant(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CaseAlt_oneof_Sum::nil(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CaseAlt_oneof_Sum::cons(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::default(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::variant(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::prim_con(is.read_enum()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::nil(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(CaseAlt_oneof_Sum::cons(is.read_message()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &CaseAlt_oneof_Sum::default(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CaseAlt_oneof_Sum::variant(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CaseAlt_oneof_Sum::prim_con(v) => {
                    my_size += ::protobuf::rt::enum_size(3, v);
                },
                &CaseAlt_oneof_Sum::nil(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CaseAlt_oneof_Sum::cons(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &CaseAlt_oneof_Sum::default(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CaseAlt_oneof_Sum::variant(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CaseAlt_oneof_Sum::prim_con(v) => {
                    os.write_enum(3, v.value())?;
                },
                &CaseAlt_oneof_Sum::nil(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CaseAlt_oneof_Sum::cons(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CaseAlt {
        CaseAlt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Unit>(
                    "default",
                    CaseAlt::has_default,
                    CaseAlt::get_default,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CaseAlt_Variant>(
                    "variant",
                    CaseAlt::has_variant,
                    CaseAlt::get_variant,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, PrimCon>(
                    "prim_con",
                    CaseAlt::has_prim_con,
                    CaseAlt::get_prim_con,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Unit>(
                    "nil",
                    CaseAlt::has_nil,
                    CaseAlt::get_nil,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CaseAlt_Cons>(
                    "cons",
                    CaseAlt::has_cons,
                    CaseAlt::get_cons,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "body",
                    |m: &CaseAlt| { &m.body },
                    |m: &mut CaseAlt| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CaseAlt>(
                    "CaseAlt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CaseAlt {
        static mut instance: ::protobuf::lazy::Lazy<CaseAlt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CaseAlt,
        };
        unsafe {
            instance.get(CaseAlt::new)
        }
    }
}

impl ::protobuf::Clear for CaseAlt {
    fn clear(&mut self) {
        self.clear_default();
        self.clear_variant();
        self.clear_prim_con();
        self.clear_nil();
        self.clear_cons();
        self.clear_body();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CaseAlt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CaseAlt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CaseAlt_Variant {
    // message fields
    pub con: ::protobuf::SingularPtrField<TypeConName>,
    pub variant: ::std::string::String,
    pub binder: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CaseAlt_Variant {
    pub fn new() -> CaseAlt_Variant {
        ::std::default::Default::default()
    }

    // .daml_lf_1.TypeConName con = 1;

    pub fn clear_con(&mut self) {
        self.con.clear();
    }

    pub fn has_con(&self) -> bool {
        self.con.is_some()
    }

    // Param is passed by value, moved
    pub fn set_con(&mut self, v: TypeConName) {
        self.con = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_con(&mut self) -> &mut TypeConName {
        if self.con.is_none() {
            self.con.set_default();
        }
        self.con.as_mut().unwrap()
    }

    // Take field
    pub fn take_con(&mut self) -> TypeConName {
        self.con.take().unwrap_or_else(|| TypeConName::new())
    }

    pub fn get_con(&self) -> &TypeConName {
        self.con.as_ref().unwrap_or_else(|| TypeConName::default_instance())
    }

    // string variant = 2;

    pub fn clear_variant(&mut self) {
        self.variant.clear();
    }

    // Param is passed by value, moved
    pub fn set_variant(&mut self, v: ::std::string::String) {
        self.variant = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_variant(&mut self) -> &mut ::std::string::String {
        &mut self.variant
    }

    // Take field
    pub fn take_variant(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.variant, ::std::string::String::new())
    }

    pub fn get_variant(&self) -> &str {
        &self.variant
    }

    // string binder = 3;

    pub fn clear_binder(&mut self) {
        self.binder.clear();
    }

    // Param is passed by value, moved
    pub fn set_binder(&mut self, v: ::std::string::String) {
        self.binder = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binder(&mut self) -> &mut ::std::string::String {
        &mut self.binder
    }

    // Take field
    pub fn take_binder(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.binder, ::std::string::String::new())
    }

    pub fn get_binder(&self) -> &str {
        &self.binder
    }
}

impl ::protobuf::Message for CaseAlt_Variant {
    fn is_initialized(&self) -> bool {
        for v in &self.con {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.con)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.variant)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.binder)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.con.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.variant.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.variant);
        }
        if !self.binder.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.binder);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.con.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.variant.is_empty() {
            os.write_string(2, &self.variant)?;
        }
        if !self.binder.is_empty() {
            os.write_string(3, &self.binder)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CaseAlt_Variant {
        CaseAlt_Variant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeConName>>(
                    "con",
                    |m: &CaseAlt_Variant| { &m.con },
                    |m: &mut CaseAlt_Variant| { &mut m.con },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "variant",
                    |m: &CaseAlt_Variant| { &m.variant },
                    |m: &mut CaseAlt_Variant| { &mut m.variant },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "binder",
                    |m: &CaseAlt_Variant| { &m.binder },
                    |m: &mut CaseAlt_Variant| { &mut m.binder },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CaseAlt_Variant>(
                    "CaseAlt_Variant",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CaseAlt_Variant {
        static mut instance: ::protobuf::lazy::Lazy<CaseAlt_Variant> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CaseAlt_Variant,
        };
        unsafe {
            instance.get(CaseAlt_Variant::new)
        }
    }
}

impl ::protobuf::Clear for CaseAlt_Variant {
    fn clear(&mut self) {
        self.clear_con();
        self.clear_variant();
        self.clear_binder();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CaseAlt_Variant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CaseAlt_Variant {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CaseAlt_Cons {
    // message fields
    pub var_head: ::std::string::String,
    pub var_tail: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CaseAlt_Cons {
    pub fn new() -> CaseAlt_Cons {
        ::std::default::Default::default()
    }

    // string var_head = 1;

    pub fn clear_var_head(&mut self) {
        self.var_head.clear();
    }

    // Param is passed by value, moved
    pub fn set_var_head(&mut self, v: ::std::string::String) {
        self.var_head = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_var_head(&mut self) -> &mut ::std::string::String {
        &mut self.var_head
    }

    // Take field
    pub fn take_var_head(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.var_head, ::std::string::String::new())
    }

    pub fn get_var_head(&self) -> &str {
        &self.var_head
    }

    // string var_tail = 2;

    pub fn clear_var_tail(&mut self) {
        self.var_tail.clear();
    }

    // Param is passed by value, moved
    pub fn set_var_tail(&mut self, v: ::std::string::String) {
        self.var_tail = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_var_tail(&mut self) -> &mut ::std::string::String {
        &mut self.var_tail
    }

    // Take field
    pub fn take_var_tail(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.var_tail, ::std::string::String::new())
    }

    pub fn get_var_tail(&self) -> &str {
        &self.var_tail
    }
}

impl ::protobuf::Message for CaseAlt_Cons {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.var_head)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.var_tail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.var_head.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.var_head);
        }
        if !self.var_tail.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.var_tail);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.var_head.is_empty() {
            os.write_string(1, &self.var_head)?;
        }
        if !self.var_tail.is_empty() {
            os.write_string(2, &self.var_tail)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CaseAlt_Cons {
        CaseAlt_Cons::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "var_head",
                    |m: &CaseAlt_Cons| { &m.var_head },
                    |m: &mut CaseAlt_Cons| { &mut m.var_head },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "var_tail",
                    |m: &CaseAlt_Cons| { &m.var_tail },
                    |m: &mut CaseAlt_Cons| { &mut m.var_tail },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CaseAlt_Cons>(
                    "CaseAlt_Cons",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CaseAlt_Cons {
        static mut instance: ::protobuf::lazy::Lazy<CaseAlt_Cons> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CaseAlt_Cons,
        };
        unsafe {
            instance.get(CaseAlt_Cons::new)
        }
    }
}

impl ::protobuf::Clear for CaseAlt_Cons {
    fn clear(&mut self) {
        self.clear_var_head();
        self.clear_var_tail();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CaseAlt_Cons {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CaseAlt_Cons {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Case {
    // message fields
    pub scrut: ::protobuf::SingularPtrField<Expr>,
    pub alts: ::protobuf::RepeatedField<CaseAlt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Case {
    pub fn new() -> Case {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Expr scrut = 1;

    pub fn clear_scrut(&mut self) {
        self.scrut.clear();
    }

    pub fn has_scrut(&self) -> bool {
        self.scrut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrut(&mut self, v: Expr) {
        self.scrut = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scrut(&mut self) -> &mut Expr {
        if self.scrut.is_none() {
            self.scrut.set_default();
        }
        self.scrut.as_mut().unwrap()
    }

    // Take field
    pub fn take_scrut(&mut self) -> Expr {
        self.scrut.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_scrut(&self) -> &Expr {
        self.scrut.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // repeated .daml_lf_1.CaseAlt alts = 2;

    pub fn clear_alts(&mut self) {
        self.alts.clear();
    }

    // Param is passed by value, moved
    pub fn set_alts(&mut self, v: ::protobuf::RepeatedField<CaseAlt>) {
        self.alts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alts(&mut self) -> &mut ::protobuf::RepeatedField<CaseAlt> {
        &mut self.alts
    }

    // Take field
    pub fn take_alts(&mut self) -> ::protobuf::RepeatedField<CaseAlt> {
        ::std::mem::replace(&mut self.alts, ::protobuf::RepeatedField::new())
    }

    pub fn get_alts(&self) -> &[CaseAlt] {
        &self.alts
    }
}

impl ::protobuf::Message for Case {
    fn is_initialized(&self) -> bool {
        for v in &self.scrut {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scrut)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.alts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scrut.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.alts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scrut.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.alts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Case {
        Case::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "scrut",
                    |m: &Case| { &m.scrut },
                    |m: &mut Case| { &mut m.scrut },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CaseAlt>>(
                    "alts",
                    |m: &Case| { &m.alts },
                    |m: &mut Case| { &mut m.alts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Case>(
                    "Case",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Case {
        static mut instance: ::protobuf::lazy::Lazy<Case> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Case,
        };
        unsafe {
            instance.get(Case::new)
        }
    }
}

impl ::protobuf::Clear for Case {
    fn clear(&mut self) {
        self.clear_scrut();
        self.clear_alts();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Case {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Case {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub bindings: ::protobuf::RepeatedField<Binding>,
    pub body: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.Binding bindings = 1;

    pub fn clear_bindings(&mut self) {
        self.bindings.clear();
    }

    // Param is passed by value, moved
    pub fn set_bindings(&mut self, v: ::protobuf::RepeatedField<Binding>) {
        self.bindings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bindings(&mut self) -> &mut ::protobuf::RepeatedField<Binding> {
        &mut self.bindings
    }

    // Take field
    pub fn take_bindings(&mut self) -> ::protobuf::RepeatedField<Binding> {
        ::std::mem::replace(&mut self.bindings, ::protobuf::RepeatedField::new())
    }

    pub fn get_bindings(&self) -> &[Binding] {
        &self.bindings
    }

    // .daml_lf_1.Expr body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Expr) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Expr {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Expr {
        self.body.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_body(&self) -> &Expr {
        self.body.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.bindings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bindings)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bindings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bindings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Binding>>(
                    "bindings",
                    |m: &Block| { &m.bindings },
                    |m: &mut Block| { &mut m.bindings },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "body",
                    |m: &Block| { &m.body },
                    |m: &mut Block| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.clear_bindings();
        self.clear_body();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pure {
    // message fields
    pub field_type: ::protobuf::SingularPtrField<Type>,
    pub expr: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Pure {
    pub fn new() -> Pure {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }

    // .daml_lf_1.Expr expr = 2;

    pub fn clear_expr(&mut self) {
        self.expr.clear();
    }

    pub fn has_expr(&self) -> bool {
        self.expr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expr(&mut self, v: Expr) {
        self.expr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expr(&mut self) -> &mut Expr {
        if self.expr.is_none() {
            self.expr.set_default();
        }
        self.expr.as_mut().unwrap()
    }

    // Take field
    pub fn take_expr(&mut self) -> Expr {
        self.expr.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_expr(&self) -> &Expr {
        self.expr.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Pure {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pure {
        Pure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &Pure| { &m.field_type },
                    |m: &mut Pure| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "expr",
                    |m: &Pure| { &m.expr },
                    |m: &mut Pure| { &mut m.expr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pure>(
                    "Pure",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Pure {
        static mut instance: ::protobuf::lazy::Lazy<Pure> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pure,
        };
        unsafe {
            instance.get(Pure::new)
        }
    }
}

impl ::protobuf::Clear for Pure {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_expr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pure {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Update {
    // message oneof groups
    pub Sum: ::std::option::Option<Update_oneof_Sum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Update_oneof_Sum {
    field_pure(Pure),
    block(Block),
    create(Update_Create),
    exercise(Update_Exercise),
    fetch(Update_Fetch),
    get_time(Unit),
    embed_expr(Update_EmbedExpr),
}

impl Update {
    pub fn new() -> Update {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Pure pure = 1;

    pub fn clear_field_pure(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_field_pure(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::field_pure(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_pure(&mut self, v: Pure) {
        self.Sum = ::std::option::Option::Some(Update_oneof_Sum::field_pure(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_pure(&mut self) -> &mut Pure {
        if let ::std::option::Option::Some(Update_oneof_Sum::field_pure(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Update_oneof_Sum::field_pure(Pure::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::field_pure(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_pure(&mut self) -> Pure {
        if self.has_field_pure() {
            match self.Sum.take() {
                ::std::option::Option::Some(Update_oneof_Sum::field_pure(v)) => v,
                _ => panic!(),
            }
        } else {
            Pure::new()
        }
    }

    pub fn get_field_pure(&self) -> &Pure {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::field_pure(ref v)) => v,
            _ => Pure::default_instance(),
        }
    }

    // .daml_lf_1.Block block = 2;

    pub fn clear_block(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: Block) {
        self.Sum = ::std::option::Option::Some(Update_oneof_Sum::block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut Block {
        if let ::std::option::Option::Some(Update_oneof_Sum::block(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Update_oneof_Sum::block(Block::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> Block {
        if self.has_block() {
            match self.Sum.take() {
                ::std::option::Option::Some(Update_oneof_Sum::block(v)) => v,
                _ => panic!(),
            }
        } else {
            Block::new()
        }
    }

    pub fn get_block(&self) -> &Block {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::block(ref v)) => v,
            _ => Block::default_instance(),
        }
    }

    // .daml_lf_1.Update.Create create = 3;

    pub fn clear_create(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_create(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::create(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: Update_Create) {
        self.Sum = ::std::option::Option::Some(Update_oneof_Sum::create(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create(&mut self) -> &mut Update_Create {
        if let ::std::option::Option::Some(Update_oneof_Sum::create(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Update_oneof_Sum::create(Update_Create::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::create(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create(&mut self) -> Update_Create {
        if self.has_create() {
            match self.Sum.take() {
                ::std::option::Option::Some(Update_oneof_Sum::create(v)) => v,
                _ => panic!(),
            }
        } else {
            Update_Create::new()
        }
    }

    pub fn get_create(&self) -> &Update_Create {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::create(ref v)) => v,
            _ => Update_Create::default_instance(),
        }
    }

    // .daml_lf_1.Update.Exercise exercise = 4;

    pub fn clear_exercise(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_exercise(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::exercise(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exercise(&mut self, v: Update_Exercise) {
        self.Sum = ::std::option::Option::Some(Update_oneof_Sum::exercise(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exercise(&mut self) -> &mut Update_Exercise {
        if let ::std::option::Option::Some(Update_oneof_Sum::exercise(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Update_oneof_Sum::exercise(Update_Exercise::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::exercise(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exercise(&mut self) -> Update_Exercise {
        if self.has_exercise() {
            match self.Sum.take() {
                ::std::option::Option::Some(Update_oneof_Sum::exercise(v)) => v,
                _ => panic!(),
            }
        } else {
            Update_Exercise::new()
        }
    }

    pub fn get_exercise(&self) -> &Update_Exercise {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::exercise(ref v)) => v,
            _ => Update_Exercise::default_instance(),
        }
    }

    // .daml_lf_1.Update.Fetch fetch = 5;

    pub fn clear_fetch(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_fetch(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::fetch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fetch(&mut self, v: Update_Fetch) {
        self.Sum = ::std::option::Option::Some(Update_oneof_Sum::fetch(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fetch(&mut self) -> &mut Update_Fetch {
        if let ::std::option::Option::Some(Update_oneof_Sum::fetch(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Update_oneof_Sum::fetch(Update_Fetch::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::fetch(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fetch(&mut self) -> Update_Fetch {
        if self.has_fetch() {
            match self.Sum.take() {
                ::std::option::Option::Some(Update_oneof_Sum::fetch(v)) => v,
                _ => panic!(),
            }
        } else {
            Update_Fetch::new()
        }
    }

    pub fn get_fetch(&self) -> &Update_Fetch {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::fetch(ref v)) => v,
            _ => Update_Fetch::default_instance(),
        }
    }

    // .daml_lf_1.Unit get_time = 6;

    pub fn clear_get_time(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_get_time(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::get_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_time(&mut self, v: Unit) {
        self.Sum = ::std::option::Option::Some(Update_oneof_Sum::get_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_time(&mut self) -> &mut Unit {
        if let ::std::option::Option::Some(Update_oneof_Sum::get_time(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Update_oneof_Sum::get_time(Unit::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::get_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_time(&mut self) -> Unit {
        if self.has_get_time() {
            match self.Sum.take() {
                ::std::option::Option::Some(Update_oneof_Sum::get_time(v)) => v,
                _ => panic!(),
            }
        } else {
            Unit::new()
        }
    }

    pub fn get_get_time(&self) -> &Unit {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::get_time(ref v)) => v,
            _ => Unit::default_instance(),
        }
    }

    // .daml_lf_1.Update.EmbedExpr embed_expr = 7;

    pub fn clear_embed_expr(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_embed_expr(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::embed_expr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_embed_expr(&mut self, v: Update_EmbedExpr) {
        self.Sum = ::std::option::Option::Some(Update_oneof_Sum::embed_expr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_embed_expr(&mut self) -> &mut Update_EmbedExpr {
        if let ::std::option::Option::Some(Update_oneof_Sum::embed_expr(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Update_oneof_Sum::embed_expr(Update_EmbedExpr::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::embed_expr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_embed_expr(&mut self) -> Update_EmbedExpr {
        if self.has_embed_expr() {
            match self.Sum.take() {
                ::std::option::Option::Some(Update_oneof_Sum::embed_expr(v)) => v,
                _ => panic!(),
            }
        } else {
            Update_EmbedExpr::new()
        }
    }

    pub fn get_embed_expr(&self) -> &Update_EmbedExpr {
        match self.Sum {
            ::std::option::Option::Some(Update_oneof_Sum::embed_expr(ref v)) => v,
            _ => Update_EmbedExpr::default_instance(),
        }
    }
}

impl ::protobuf::Message for Update {
    fn is_initialized(&self) -> bool {
        if let Some(Update_oneof_Sum::field_pure(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Update_oneof_Sum::block(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Update_oneof_Sum::create(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Update_oneof_Sum::exercise(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Update_oneof_Sum::fetch(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Update_oneof_Sum::get_time(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Update_oneof_Sum::embed_expr(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Update_oneof_Sum::field_pure(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Update_oneof_Sum::block(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Update_oneof_Sum::create(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Update_oneof_Sum::exercise(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Update_oneof_Sum::fetch(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Update_oneof_Sum::get_time(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Update_oneof_Sum::embed_expr(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Update_oneof_Sum::field_pure(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Update_oneof_Sum::block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Update_oneof_Sum::create(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Update_oneof_Sum::exercise(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Update_oneof_Sum::fetch(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Update_oneof_Sum::get_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Update_oneof_Sum::embed_expr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Update_oneof_Sum::field_pure(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Update_oneof_Sum::block(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Update_oneof_Sum::create(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Update_oneof_Sum::exercise(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Update_oneof_Sum::fetch(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Update_oneof_Sum::get_time(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Update_oneof_Sum::embed_expr(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Update {
        Update::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Pure>(
                    "pure",
                    Update::has_field_pure,
                    Update::get_field_pure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Block>(
                    "block",
                    Update::has_block,
                    Update::get_block,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Update_Create>(
                    "create",
                    Update::has_create,
                    Update::get_create,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Update_Exercise>(
                    "exercise",
                    Update::has_exercise,
                    Update::get_exercise,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Update_Fetch>(
                    "fetch",
                    Update::has_fetch,
                    Update::get_fetch,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Unit>(
                    "get_time",
                    Update::has_get_time,
                    Update::get_get_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Update_EmbedExpr>(
                    "embed_expr",
                    Update::has_embed_expr,
                    Update::get_embed_expr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Update>(
                    "Update",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Update {
        static mut instance: ::protobuf::lazy::Lazy<Update> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Update,
        };
        unsafe {
            instance.get(Update::new)
        }
    }
}

impl ::protobuf::Clear for Update {
    fn clear(&mut self) {
        self.clear_field_pure();
        self.clear_block();
        self.clear_create();
        self.clear_exercise();
        self.clear_fetch();
        self.clear_get_time();
        self.clear_embed_expr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Update {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Update_Create {
    // message fields
    pub template: ::protobuf::SingularPtrField<TypeConName>,
    pub expr: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Update_Create {
    pub fn new() -> Update_Create {
        ::std::default::Default::default()
    }

    // .daml_lf_1.TypeConName template = 1;

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: TypeConName) {
        self.template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut TypeConName {
        if self.template.is_none() {
            self.template.set_default();
        }
        self.template.as_mut().unwrap()
    }

    // Take field
    pub fn take_template(&mut self) -> TypeConName {
        self.template.take().unwrap_or_else(|| TypeConName::new())
    }

    pub fn get_template(&self) -> &TypeConName {
        self.template.as_ref().unwrap_or_else(|| TypeConName::default_instance())
    }

    // .daml_lf_1.Expr expr = 2;

    pub fn clear_expr(&mut self) {
        self.expr.clear();
    }

    pub fn has_expr(&self) -> bool {
        self.expr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expr(&mut self, v: Expr) {
        self.expr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expr(&mut self) -> &mut Expr {
        if self.expr.is_none() {
            self.expr.set_default();
        }
        self.expr.as_mut().unwrap()
    }

    // Take field
    pub fn take_expr(&mut self) -> Expr {
        self.expr.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_expr(&self) -> &Expr {
        self.expr.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Update_Create {
    fn is_initialized(&self) -> bool {
        for v in &self.template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.template.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Update_Create {
        Update_Create::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeConName>>(
                    "template",
                    |m: &Update_Create| { &m.template },
                    |m: &mut Update_Create| { &mut m.template },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "expr",
                    |m: &Update_Create| { &m.expr },
                    |m: &mut Update_Create| { &mut m.expr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Update_Create>(
                    "Update_Create",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Update_Create {
        static mut instance: ::protobuf::lazy::Lazy<Update_Create> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Update_Create,
        };
        unsafe {
            instance.get(Update_Create::new)
        }
    }
}

impl ::protobuf::Clear for Update_Create {
    fn clear(&mut self) {
        self.clear_template();
        self.clear_expr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Update_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Update_Create {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Update_Exercise {
    // message fields
    pub template: ::protobuf::SingularPtrField<TypeConName>,
    pub choice: ::std::string::String,
    pub cid: ::protobuf::SingularPtrField<Expr>,
    pub actor: ::protobuf::SingularPtrField<Expr>,
    pub arg: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Update_Exercise {
    pub fn new() -> Update_Exercise {
        ::std::default::Default::default()
    }

    // .daml_lf_1.TypeConName template = 1;

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: TypeConName) {
        self.template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut TypeConName {
        if self.template.is_none() {
            self.template.set_default();
        }
        self.template.as_mut().unwrap()
    }

    // Take field
    pub fn take_template(&mut self) -> TypeConName {
        self.template.take().unwrap_or_else(|| TypeConName::new())
    }

    pub fn get_template(&self) -> &TypeConName {
        self.template.as_ref().unwrap_or_else(|| TypeConName::default_instance())
    }

    // string choice = 2;

    pub fn clear_choice(&mut self) {
        self.choice.clear();
    }

    // Param is passed by value, moved
    pub fn set_choice(&mut self, v: ::std::string::String) {
        self.choice = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_choice(&mut self) -> &mut ::std::string::String {
        &mut self.choice
    }

    // Take field
    pub fn take_choice(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.choice, ::std::string::String::new())
    }

    pub fn get_choice(&self) -> &str {
        &self.choice
    }

    // .daml_lf_1.Expr cid = 3;

    pub fn clear_cid(&mut self) {
        self.cid.clear();
    }

    pub fn has_cid(&self) -> bool {
        self.cid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cid(&mut self, v: Expr) {
        self.cid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cid(&mut self) -> &mut Expr {
        if self.cid.is_none() {
            self.cid.set_default();
        }
        self.cid.as_mut().unwrap()
    }

    // Take field
    pub fn take_cid(&mut self) -> Expr {
        self.cid.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_cid(&self) -> &Expr {
        self.cid.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.Expr actor = 4;

    pub fn clear_actor(&mut self) {
        self.actor.clear();
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: Expr) {
        self.actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor(&mut self) -> &mut Expr {
        if self.actor.is_none() {
            self.actor.set_default();
        }
        self.actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_actor(&mut self) -> Expr {
        self.actor.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_actor(&self) -> &Expr {
        self.actor.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.Expr arg = 5;

    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: Expr) {
        self.arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut Expr {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> Expr {
        self.arg.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_arg(&self) -> &Expr {
        self.arg.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Update_Exercise {
    fn is_initialized(&self) -> bool {
        for v in &self.template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.choice)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actor)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.arg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.choice.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.choice);
        }
        if let Some(ref v) = self.cid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.template.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.choice.is_empty() {
            os.write_string(2, &self.choice)?;
        }
        if let Some(ref v) = self.cid.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.actor.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.arg.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Update_Exercise {
        Update_Exercise::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeConName>>(
                    "template",
                    |m: &Update_Exercise| { &m.template },
                    |m: &mut Update_Exercise| { &mut m.template },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "choice",
                    |m: &Update_Exercise| { &m.choice },
                    |m: &mut Update_Exercise| { &mut m.choice },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "cid",
                    |m: &Update_Exercise| { &m.cid },
                    |m: &mut Update_Exercise| { &mut m.cid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "actor",
                    |m: &Update_Exercise| { &m.actor },
                    |m: &mut Update_Exercise| { &mut m.actor },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "arg",
                    |m: &Update_Exercise| { &m.arg },
                    |m: &mut Update_Exercise| { &mut m.arg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Update_Exercise>(
                    "Update_Exercise",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Update_Exercise {
        static mut instance: ::protobuf::lazy::Lazy<Update_Exercise> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Update_Exercise,
        };
        unsafe {
            instance.get(Update_Exercise::new)
        }
    }
}

impl ::protobuf::Clear for Update_Exercise {
    fn clear(&mut self) {
        self.clear_template();
        self.clear_choice();
        self.clear_cid();
        self.clear_actor();
        self.clear_arg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Update_Exercise {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Update_Exercise {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Update_Fetch {
    // message fields
    pub template: ::protobuf::SingularPtrField<TypeConName>,
    pub cid: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Update_Fetch {
    pub fn new() -> Update_Fetch {
        ::std::default::Default::default()
    }

    // .daml_lf_1.TypeConName template = 1;

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: TypeConName) {
        self.template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut TypeConName {
        if self.template.is_none() {
            self.template.set_default();
        }
        self.template.as_mut().unwrap()
    }

    // Take field
    pub fn take_template(&mut self) -> TypeConName {
        self.template.take().unwrap_or_else(|| TypeConName::new())
    }

    pub fn get_template(&self) -> &TypeConName {
        self.template.as_ref().unwrap_or_else(|| TypeConName::default_instance())
    }

    // .daml_lf_1.Expr cid = 2;

    pub fn clear_cid(&mut self) {
        self.cid.clear();
    }

    pub fn has_cid(&self) -> bool {
        self.cid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cid(&mut self, v: Expr) {
        self.cid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cid(&mut self) -> &mut Expr {
        if self.cid.is_none() {
            self.cid.set_default();
        }
        self.cid.as_mut().unwrap()
    }

    // Take field
    pub fn take_cid(&mut self) -> Expr {
        self.cid.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_cid(&self) -> &Expr {
        self.cid.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Update_Fetch {
    fn is_initialized(&self) -> bool {
        for v in &self.template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.template.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cid.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Update_Fetch {
        Update_Fetch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeConName>>(
                    "template",
                    |m: &Update_Fetch| { &m.template },
                    |m: &mut Update_Fetch| { &mut m.template },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "cid",
                    |m: &Update_Fetch| { &m.cid },
                    |m: &mut Update_Fetch| { &mut m.cid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Update_Fetch>(
                    "Update_Fetch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Update_Fetch {
        static mut instance: ::protobuf::lazy::Lazy<Update_Fetch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Update_Fetch,
        };
        unsafe {
            instance.get(Update_Fetch::new)
        }
    }
}

impl ::protobuf::Clear for Update_Fetch {
    fn clear(&mut self) {
        self.clear_template();
        self.clear_cid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Update_Fetch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Update_Fetch {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Update_EmbedExpr {
    // message fields
    pub field_type: ::protobuf::SingularPtrField<Type>,
    pub body: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Update_EmbedExpr {
    pub fn new() -> Update_EmbedExpr {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }

    // .daml_lf_1.Expr body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Expr) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Expr {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Expr {
        self.body.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_body(&self) -> &Expr {
        self.body.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Update_EmbedExpr {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Update_EmbedExpr {
        Update_EmbedExpr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &Update_EmbedExpr| { &m.field_type },
                    |m: &mut Update_EmbedExpr| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "body",
                    |m: &Update_EmbedExpr| { &m.body },
                    |m: &mut Update_EmbedExpr| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Update_EmbedExpr>(
                    "Update_EmbedExpr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Update_EmbedExpr {
        static mut instance: ::protobuf::lazy::Lazy<Update_EmbedExpr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Update_EmbedExpr,
        };
        unsafe {
            instance.get(Update_EmbedExpr::new)
        }
    }
}

impl ::protobuf::Clear for Update_EmbedExpr {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_body();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Update_EmbedExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Update_EmbedExpr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Scenario {
    // message oneof groups
    pub Sum: ::std::option::Option<Scenario_oneof_Sum>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Scenario_oneof_Sum {
    field_pure(Pure),
    block(Block),
    commit(Scenario_Commit),
    mustFailAt(Scenario_Commit),
    get_time(Unit),
    embed_expr(Scenario_EmbedExpr),
}

impl Scenario {
    pub fn new() -> Scenario {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Pure pure = 1;

    pub fn clear_field_pure(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_field_pure(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::field_pure(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_pure(&mut self, v: Pure) {
        self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::field_pure(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_pure(&mut self) -> &mut Pure {
        if let ::std::option::Option::Some(Scenario_oneof_Sum::field_pure(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::field_pure(Pure::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::field_pure(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_pure(&mut self) -> Pure {
        if self.has_field_pure() {
            match self.Sum.take() {
                ::std::option::Option::Some(Scenario_oneof_Sum::field_pure(v)) => v,
                _ => panic!(),
            }
        } else {
            Pure::new()
        }
    }

    pub fn get_field_pure(&self) -> &Pure {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::field_pure(ref v)) => v,
            _ => Pure::default_instance(),
        }
    }

    // .daml_lf_1.Block block = 2;

    pub fn clear_block(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_block(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: Block) {
        self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut Block {
        if let ::std::option::Option::Some(Scenario_oneof_Sum::block(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::block(Block::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block(&mut self) -> Block {
        if self.has_block() {
            match self.Sum.take() {
                ::std::option::Option::Some(Scenario_oneof_Sum::block(v)) => v,
                _ => panic!(),
            }
        } else {
            Block::new()
        }
    }

    pub fn get_block(&self) -> &Block {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::block(ref v)) => v,
            _ => Block::default_instance(),
        }
    }

    // .daml_lf_1.Scenario.Commit commit = 3;

    pub fn clear_commit(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_commit(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::commit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_commit(&mut self, v: Scenario_Commit) {
        self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::commit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_commit(&mut self) -> &mut Scenario_Commit {
        if let ::std::option::Option::Some(Scenario_oneof_Sum::commit(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::commit(Scenario_Commit::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::commit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_commit(&mut self) -> Scenario_Commit {
        if self.has_commit() {
            match self.Sum.take() {
                ::std::option::Option::Some(Scenario_oneof_Sum::commit(v)) => v,
                _ => panic!(),
            }
        } else {
            Scenario_Commit::new()
        }
    }

    pub fn get_commit(&self) -> &Scenario_Commit {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::commit(ref v)) => v,
            _ => Scenario_Commit::default_instance(),
        }
    }

    // .daml_lf_1.Scenario.Commit mustFailAt = 4;

    pub fn clear_mustFailAt(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_mustFailAt(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::mustFailAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mustFailAt(&mut self, v: Scenario_Commit) {
        self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::mustFailAt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mustFailAt(&mut self) -> &mut Scenario_Commit {
        if let ::std::option::Option::Some(Scenario_oneof_Sum::mustFailAt(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::mustFailAt(Scenario_Commit::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::mustFailAt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mustFailAt(&mut self) -> Scenario_Commit {
        if self.has_mustFailAt() {
            match self.Sum.take() {
                ::std::option::Option::Some(Scenario_oneof_Sum::mustFailAt(v)) => v,
                _ => panic!(),
            }
        } else {
            Scenario_Commit::new()
        }
    }

    pub fn get_mustFailAt(&self) -> &Scenario_Commit {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::mustFailAt(ref v)) => v,
            _ => Scenario_Commit::default_instance(),
        }
    }

    // .daml_lf_1.Unit get_time = 6;

    pub fn clear_get_time(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_get_time(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::get_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_time(&mut self, v: Unit) {
        self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::get_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_time(&mut self) -> &mut Unit {
        if let ::std::option::Option::Some(Scenario_oneof_Sum::get_time(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::get_time(Unit::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::get_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_time(&mut self) -> Unit {
        if self.has_get_time() {
            match self.Sum.take() {
                ::std::option::Option::Some(Scenario_oneof_Sum::get_time(v)) => v,
                _ => panic!(),
            }
        } else {
            Unit::new()
        }
    }

    pub fn get_get_time(&self) -> &Unit {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::get_time(ref v)) => v,
            _ => Unit::default_instance(),
        }
    }

    // .daml_lf_1.Scenario.EmbedExpr embed_expr = 8;

    pub fn clear_embed_expr(&mut self) {
        self.Sum = ::std::option::Option::None;
    }

    pub fn has_embed_expr(&self) -> bool {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::embed_expr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_embed_expr(&mut self, v: Scenario_EmbedExpr) {
        self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::embed_expr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_embed_expr(&mut self) -> &mut Scenario_EmbedExpr {
        if let ::std::option::Option::Some(Scenario_oneof_Sum::embed_expr(_)) = self.Sum {
        } else {
            self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::embed_expr(Scenario_EmbedExpr::new()));
        }
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::embed_expr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_embed_expr(&mut self) -> Scenario_EmbedExpr {
        if self.has_embed_expr() {
            match self.Sum.take() {
                ::std::option::Option::Some(Scenario_oneof_Sum::embed_expr(v)) => v,
                _ => panic!(),
            }
        } else {
            Scenario_EmbedExpr::new()
        }
    }

    pub fn get_embed_expr(&self) -> &Scenario_EmbedExpr {
        match self.Sum {
            ::std::option::Option::Some(Scenario_oneof_Sum::embed_expr(ref v)) => v,
            _ => Scenario_EmbedExpr::default_instance(),
        }
    }
}

impl ::protobuf::Message for Scenario {
    fn is_initialized(&self) -> bool {
        if let Some(Scenario_oneof_Sum::field_pure(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Scenario_oneof_Sum::block(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Scenario_oneof_Sum::commit(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Scenario_oneof_Sum::mustFailAt(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Scenario_oneof_Sum::get_time(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Scenario_oneof_Sum::embed_expr(ref v)) = self.Sum {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::field_pure(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::block(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::commit(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::mustFailAt(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::get_time(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.Sum = ::std::option::Option::Some(Scenario_oneof_Sum::embed_expr(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Scenario_oneof_Sum::field_pure(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Scenario_oneof_Sum::block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Scenario_oneof_Sum::commit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Scenario_oneof_Sum::mustFailAt(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Scenario_oneof_Sum::get_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Scenario_oneof_Sum::embed_expr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.Sum {
            match v {
                &Scenario_oneof_Sum::field_pure(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Scenario_oneof_Sum::block(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Scenario_oneof_Sum::commit(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Scenario_oneof_Sum::mustFailAt(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Scenario_oneof_Sum::get_time(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Scenario_oneof_Sum::embed_expr(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Scenario {
        Scenario::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Pure>(
                    "pure",
                    Scenario::has_field_pure,
                    Scenario::get_field_pure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Block>(
                    "block",
                    Scenario::has_block,
                    Scenario::get_block,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Scenario_Commit>(
                    "commit",
                    Scenario::has_commit,
                    Scenario::get_commit,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Scenario_Commit>(
                    "mustFailAt",
                    Scenario::has_mustFailAt,
                    Scenario::get_mustFailAt,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Unit>(
                    "get_time",
                    Scenario::has_get_time,
                    Scenario::get_get_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Scenario_EmbedExpr>(
                    "embed_expr",
                    Scenario::has_embed_expr,
                    Scenario::get_embed_expr,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Scenario>(
                    "Scenario",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Scenario {
        static mut instance: ::protobuf::lazy::Lazy<Scenario> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Scenario,
        };
        unsafe {
            instance.get(Scenario::new)
        }
    }
}

impl ::protobuf::Clear for Scenario {
    fn clear(&mut self) {
        self.clear_field_pure();
        self.clear_block();
        self.clear_commit();
        self.clear_mustFailAt();
        self.clear_get_time();
        self.clear_embed_expr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Scenario {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scenario {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Scenario_Commit {
    // message fields
    pub party: ::protobuf::SingularPtrField<Expr>,
    pub expr: ::protobuf::SingularPtrField<Expr>,
    pub ret_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Scenario_Commit {
    pub fn new() -> Scenario_Commit {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Expr party = 1;

    pub fn clear_party(&mut self) {
        self.party.clear();
    }

    pub fn has_party(&self) -> bool {
        self.party.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party(&mut self, v: Expr) {
        self.party = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_party(&mut self) -> &mut Expr {
        if self.party.is_none() {
            self.party.set_default();
        }
        self.party.as_mut().unwrap()
    }

    // Take field
    pub fn take_party(&mut self) -> Expr {
        self.party.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_party(&self) -> &Expr {
        self.party.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.Expr expr = 2;

    pub fn clear_expr(&mut self) {
        self.expr.clear();
    }

    pub fn has_expr(&self) -> bool {
        self.expr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expr(&mut self, v: Expr) {
        self.expr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expr(&mut self) -> &mut Expr {
        if self.expr.is_none() {
            self.expr.set_default();
        }
        self.expr.as_mut().unwrap()
    }

    // Take field
    pub fn take_expr(&mut self) -> Expr {
        self.expr.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_expr(&self) -> &Expr {
        self.expr.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.Type ret_type = 3;

    pub fn clear_ret_type(&mut self) {
        self.ret_type.clear();
    }

    pub fn has_ret_type(&self) -> bool {
        self.ret_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ret_type(&mut self, v: Type) {
        self.ret_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ret_type(&mut self) -> &mut Type {
        if self.ret_type.is_none() {
            self.ret_type.set_default();
        }
        self.ret_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_ret_type(&mut self) -> Type {
        self.ret_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_ret_type(&self) -> &Type {
        self.ret_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
}

impl ::protobuf::Message for Scenario_Commit {
    fn is_initialized(&self) -> bool {
        for v in &self.party {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ret_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.party)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ret_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.party.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ret_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.party.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ret_type.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Scenario_Commit {
        Scenario_Commit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "party",
                    |m: &Scenario_Commit| { &m.party },
                    |m: &mut Scenario_Commit| { &mut m.party },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "expr",
                    |m: &Scenario_Commit| { &m.expr },
                    |m: &mut Scenario_Commit| { &mut m.expr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "ret_type",
                    |m: &Scenario_Commit| { &m.ret_type },
                    |m: &mut Scenario_Commit| { &mut m.ret_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Scenario_Commit>(
                    "Scenario_Commit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Scenario_Commit {
        static mut instance: ::protobuf::lazy::Lazy<Scenario_Commit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Scenario_Commit,
        };
        unsafe {
            instance.get(Scenario_Commit::new)
        }
    }
}

impl ::protobuf::Clear for Scenario_Commit {
    fn clear(&mut self) {
        self.clear_party();
        self.clear_expr();
        self.clear_ret_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Scenario_Commit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scenario_Commit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Scenario_EmbedExpr {
    // message fields
    pub field_type: ::protobuf::SingularPtrField<Type>,
    pub body: ::protobuf::SingularPtrField<Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Scenario_EmbedExpr {
    pub fn new() -> Scenario_EmbedExpr {
        ::std::default::Default::default()
    }

    // .daml_lf_1.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }

    // .daml_lf_1.Expr body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Expr) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut Expr {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Expr {
        self.body.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_body(&self) -> &Expr {
        self.body.as_ref().unwrap_or_else(|| Expr::default_instance())
    }
}

impl ::protobuf::Message for Scenario_EmbedExpr {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Scenario_EmbedExpr {
        Scenario_EmbedExpr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &Scenario_EmbedExpr| { &m.field_type },
                    |m: &mut Scenario_EmbedExpr| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "body",
                    |m: &Scenario_EmbedExpr| { &m.body },
                    |m: &mut Scenario_EmbedExpr| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Scenario_EmbedExpr>(
                    "Scenario_EmbedExpr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Scenario_EmbedExpr {
        static mut instance: ::protobuf::lazy::Lazy<Scenario_EmbedExpr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Scenario_EmbedExpr,
        };
        unsafe {
            instance.get(Scenario_EmbedExpr::new)
        }
    }
}

impl ::protobuf::Clear for Scenario_EmbedExpr {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_body();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Scenario_EmbedExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Scenario_EmbedExpr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TemplateChoice {
    // message fields
    pub name: ::std::string::String,
    pub consuming: bool,
    pub controllers: ::protobuf::SingularPtrField<Expr>,
    pub arg_binder: ::protobuf::SingularPtrField<VarWithType>,
    pub ret_type: ::protobuf::SingularPtrField<Type>,
    pub update: ::protobuf::SingularPtrField<Expr>,
    pub self_binder: ::std::string::String,
    pub location: ::protobuf::SingularPtrField<Location>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TemplateChoice {
    pub fn new() -> TemplateChoice {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // bool consuming = 2;

    pub fn clear_consuming(&mut self) {
        self.consuming = false;
    }

    // Param is passed by value, moved
    pub fn set_consuming(&mut self, v: bool) {
        self.consuming = v;
    }

    pub fn get_consuming(&self) -> bool {
        self.consuming
    }

    // .daml_lf_1.Expr controllers = 3;

    pub fn clear_controllers(&mut self) {
        self.controllers.clear();
    }

    pub fn has_controllers(&self) -> bool {
        self.controllers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controllers(&mut self, v: Expr) {
        self.controllers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controllers(&mut self) -> &mut Expr {
        if self.controllers.is_none() {
            self.controllers.set_default();
        }
        self.controllers.as_mut().unwrap()
    }

    // Take field
    pub fn take_controllers(&mut self) -> Expr {
        self.controllers.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_controllers(&self) -> &Expr {
        self.controllers.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.VarWithType arg_binder = 4;

    pub fn clear_arg_binder(&mut self) {
        self.arg_binder.clear();
    }

    pub fn has_arg_binder(&self) -> bool {
        self.arg_binder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg_binder(&mut self, v: VarWithType) {
        self.arg_binder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg_binder(&mut self) -> &mut VarWithType {
        if self.arg_binder.is_none() {
            self.arg_binder.set_default();
        }
        self.arg_binder.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg_binder(&mut self) -> VarWithType {
        self.arg_binder.take().unwrap_or_else(|| VarWithType::new())
    }

    pub fn get_arg_binder(&self) -> &VarWithType {
        self.arg_binder.as_ref().unwrap_or_else(|| VarWithType::default_instance())
    }

    // .daml_lf_1.Type ret_type = 5;

    pub fn clear_ret_type(&mut self) {
        self.ret_type.clear();
    }

    pub fn has_ret_type(&self) -> bool {
        self.ret_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ret_type(&mut self, v: Type) {
        self.ret_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ret_type(&mut self) -> &mut Type {
        if self.ret_type.is_none() {
            self.ret_type.set_default();
        }
        self.ret_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_ret_type(&mut self) -> Type {
        self.ret_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_ret_type(&self) -> &Type {
        self.ret_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }

    // .daml_lf_1.Expr update = 6;

    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: Expr) {
        self.update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut Expr {
        if self.update.is_none() {
            self.update.set_default();
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> Expr {
        self.update.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_update(&self) -> &Expr {
        self.update.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // string self_binder = 7;

    pub fn clear_self_binder(&mut self) {
        self.self_binder.clear();
    }

    // Param is passed by value, moved
    pub fn set_self_binder(&mut self, v: ::std::string::String) {
        self.self_binder = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_self_binder(&mut self) -> &mut ::std::string::String {
        &mut self.self_binder
    }

    // Take field
    pub fn take_self_binder(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.self_binder, ::std::string::String::new())
    }

    pub fn get_self_binder(&self) -> &str {
        &self.self_binder
    }

    // .daml_lf_1.Location location = 8;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Location) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut Location {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> Location {
        self.location.take().unwrap_or_else(|| Location::new())
    }

    pub fn get_location(&self) -> &Location {
        self.location.as_ref().unwrap_or_else(|| Location::default_instance())
    }
}

impl ::protobuf::Message for TemplateChoice {
    fn is_initialized(&self) -> bool {
        for v in &self.controllers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arg_binder {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ret_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.consuming = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controllers)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.arg_binder)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ret_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.self_binder)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.consuming != false {
            my_size += 2;
        }
        if let Some(ref v) = self.controllers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.arg_binder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ret_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.self_binder.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.self_binder);
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.consuming != false {
            os.write_bool(2, self.consuming)?;
        }
        if let Some(ref v) = self.controllers.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.arg_binder.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ret_type.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.self_binder.is_empty() {
            os.write_string(7, &self.self_binder)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TemplateChoice {
        TemplateChoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &TemplateChoice| { &m.name },
                    |m: &mut TemplateChoice| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "consuming",
                    |m: &TemplateChoice| { &m.consuming },
                    |m: &mut TemplateChoice| { &mut m.consuming },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "controllers",
                    |m: &TemplateChoice| { &m.controllers },
                    |m: &mut TemplateChoice| { &mut m.controllers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VarWithType>>(
                    "arg_binder",
                    |m: &TemplateChoice| { &m.arg_binder },
                    |m: &mut TemplateChoice| { &mut m.arg_binder },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "ret_type",
                    |m: &TemplateChoice| { &m.ret_type },
                    |m: &mut TemplateChoice| { &mut m.ret_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "update",
                    |m: &TemplateChoice| { &m.update },
                    |m: &mut TemplateChoice| { &mut m.update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "self_binder",
                    |m: &TemplateChoice| { &m.self_binder },
                    |m: &mut TemplateChoice| { &mut m.self_binder },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Location>>(
                    "location",
                    |m: &TemplateChoice| { &m.location },
                    |m: &mut TemplateChoice| { &mut m.location },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TemplateChoice>(
                    "TemplateChoice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TemplateChoice {
        static mut instance: ::protobuf::lazy::Lazy<TemplateChoice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TemplateChoice,
        };
        unsafe {
            instance.get(TemplateChoice::new)
        }
    }
}

impl ::protobuf::Clear for TemplateChoice {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_consuming();
        self.clear_controllers();
        self.clear_arg_binder();
        self.clear_ret_type();
        self.clear_update();
        self.clear_self_binder();
        self.clear_location();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TemplateChoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateChoice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefTemplate {
    // message fields
    pub tycon: ::protobuf::SingularPtrField<DottedName>,
    pub param: ::std::string::String,
    pub precond: ::protobuf::SingularPtrField<Expr>,
    pub signatories: ::protobuf::SingularPtrField<Expr>,
    pub agreement: ::protobuf::SingularPtrField<Expr>,
    pub choices: ::protobuf::RepeatedField<TemplateChoice>,
    pub observers: ::protobuf::SingularPtrField<Expr>,
    pub location: ::protobuf::SingularPtrField<Location>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DefTemplate {
    pub fn new() -> DefTemplate {
        ::std::default::Default::default()
    }

    // .daml_lf_1.DottedName tycon = 1;

    pub fn clear_tycon(&mut self) {
        self.tycon.clear();
    }

    pub fn has_tycon(&self) -> bool {
        self.tycon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tycon(&mut self, v: DottedName) {
        self.tycon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tycon(&mut self) -> &mut DottedName {
        if self.tycon.is_none() {
            self.tycon.set_default();
        }
        self.tycon.as_mut().unwrap()
    }

    // Take field
    pub fn take_tycon(&mut self) -> DottedName {
        self.tycon.take().unwrap_or_else(|| DottedName::new())
    }

    pub fn get_tycon(&self) -> &DottedName {
        self.tycon.as_ref().unwrap_or_else(|| DottedName::default_instance())
    }

    // string param = 2;

    pub fn clear_param(&mut self) {
        self.param.clear();
    }

    // Param is passed by value, moved
    pub fn set_param(&mut self, v: ::std::string::String) {
        self.param = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param(&mut self) -> &mut ::std::string::String {
        &mut self.param
    }

    // Take field
    pub fn take_param(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.param, ::std::string::String::new())
    }

    pub fn get_param(&self) -> &str {
        &self.param
    }

    // .daml_lf_1.Expr precond = 4;

    pub fn clear_precond(&mut self) {
        self.precond.clear();
    }

    pub fn has_precond(&self) -> bool {
        self.precond.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precond(&mut self, v: Expr) {
        self.precond = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_precond(&mut self) -> &mut Expr {
        if self.precond.is_none() {
            self.precond.set_default();
        }
        self.precond.as_mut().unwrap()
    }

    // Take field
    pub fn take_precond(&mut self) -> Expr {
        self.precond.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_precond(&self) -> &Expr {
        self.precond.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.Expr signatories = 5;

    pub fn clear_signatories(&mut self) {
        self.signatories.clear();
    }

    pub fn has_signatories(&self) -> bool {
        self.signatories.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signatories(&mut self, v: Expr) {
        self.signatories = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signatories(&mut self) -> &mut Expr {
        if self.signatories.is_none() {
            self.signatories.set_default();
        }
        self.signatories.as_mut().unwrap()
    }

    // Take field
    pub fn take_signatories(&mut self) -> Expr {
        self.signatories.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_signatories(&self) -> &Expr {
        self.signatories.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.Expr agreement = 6;

    pub fn clear_agreement(&mut self) {
        self.agreement.clear();
    }

    pub fn has_agreement(&self) -> bool {
        self.agreement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agreement(&mut self, v: Expr) {
        self.agreement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agreement(&mut self) -> &mut Expr {
        if self.agreement.is_none() {
            self.agreement.set_default();
        }
        self.agreement.as_mut().unwrap()
    }

    // Take field
    pub fn take_agreement(&mut self) -> Expr {
        self.agreement.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_agreement(&self) -> &Expr {
        self.agreement.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // repeated .daml_lf_1.TemplateChoice choices = 7;

    pub fn clear_choices(&mut self) {
        self.choices.clear();
    }

    // Param is passed by value, moved
    pub fn set_choices(&mut self, v: ::protobuf::RepeatedField<TemplateChoice>) {
        self.choices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choices(&mut self) -> &mut ::protobuf::RepeatedField<TemplateChoice> {
        &mut self.choices
    }

    // Take field
    pub fn take_choices(&mut self) -> ::protobuf::RepeatedField<TemplateChoice> {
        ::std::mem::replace(&mut self.choices, ::protobuf::RepeatedField::new())
    }

    pub fn get_choices(&self) -> &[TemplateChoice] {
        &self.choices
    }

    // .daml_lf_1.Expr observers = 8;

    pub fn clear_observers(&mut self) {
        self.observers.clear();
    }

    pub fn has_observers(&self) -> bool {
        self.observers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observers(&mut self, v: Expr) {
        self.observers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_observers(&mut self) -> &mut Expr {
        if self.observers.is_none() {
            self.observers.set_default();
        }
        self.observers.as_mut().unwrap()
    }

    // Take field
    pub fn take_observers(&mut self) -> Expr {
        self.observers.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_observers(&self) -> &Expr {
        self.observers.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // .daml_lf_1.Location location = 9;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Location) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut Location {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> Location {
        self.location.take().unwrap_or_else(|| Location::new())
    }

    pub fn get_location(&self) -> &Location {
        self.location.as_ref().unwrap_or_else(|| Location::default_instance())
    }
}

impl ::protobuf::Message for DefTemplate {
    fn is_initialized(&self) -> bool {
        for v in &self.tycon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.precond {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signatories {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.agreement {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.choices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.observers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tycon)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.param)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.precond)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signatories)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agreement)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.choices)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.observers)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tycon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.param.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.param);
        }
        if let Some(ref v) = self.precond.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.signatories.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.agreement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.choices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.observers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tycon.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.param.is_empty() {
            os.write_string(2, &self.param)?;
        }
        if let Some(ref v) = self.precond.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.signatories.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.agreement.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.choices {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.observers.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefTemplate {
        DefTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DottedName>>(
                    "tycon",
                    |m: &DefTemplate| { &m.tycon },
                    |m: &mut DefTemplate| { &mut m.tycon },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "param",
                    |m: &DefTemplate| { &m.param },
                    |m: &mut DefTemplate| { &mut m.param },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "precond",
                    |m: &DefTemplate| { &m.precond },
                    |m: &mut DefTemplate| { &mut m.precond },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "signatories",
                    |m: &DefTemplate| { &m.signatories },
                    |m: &mut DefTemplate| { &mut m.signatories },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "agreement",
                    |m: &DefTemplate| { &m.agreement },
                    |m: &mut DefTemplate| { &mut m.agreement },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TemplateChoice>>(
                    "choices",
                    |m: &DefTemplate| { &m.choices },
                    |m: &mut DefTemplate| { &mut m.choices },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "observers",
                    |m: &DefTemplate| { &m.observers },
                    |m: &mut DefTemplate| { &mut m.observers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Location>>(
                    "location",
                    |m: &DefTemplate| { &m.location },
                    |m: &mut DefTemplate| { &mut m.location },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DefTemplate>(
                    "DefTemplate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefTemplate {
        static mut instance: ::protobuf::lazy::Lazy<DefTemplate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefTemplate,
        };
        unsafe {
            instance.get(DefTemplate::new)
        }
    }
}

impl ::protobuf::Clear for DefTemplate {
    fn clear(&mut self) {
        self.clear_tycon();
        self.clear_param();
        self.clear_precond();
        self.clear_signatories();
        self.clear_agreement();
        self.clear_choices();
        self.clear_observers();
        self.clear_location();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefDataType {
    // message fields
    pub name: ::protobuf::SingularPtrField<DottedName>,
    pub params: ::protobuf::RepeatedField<TypeVarWithKind>,
    pub serializable: bool,
    pub location: ::protobuf::SingularPtrField<Location>,
    // message oneof groups
    pub DataCons: ::std::option::Option<DefDataType_oneof_DataCons>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum DefDataType_oneof_DataCons {
    record(DefDataType_Fields),
    variant(DefDataType_Fields),
}

impl DefDataType {
    pub fn new() -> DefDataType {
        ::std::default::Default::default()
    }

    // .daml_lf_1.DottedName name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: DottedName) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut DottedName {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> DottedName {
        self.name.take().unwrap_or_else(|| DottedName::new())
    }

    pub fn get_name(&self) -> &DottedName {
        self.name.as_ref().unwrap_or_else(|| DottedName::default_instance())
    }

    // repeated .daml_lf_1.TypeVarWithKind params = 2;

    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<TypeVarWithKind>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<TypeVarWithKind> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<TypeVarWithKind> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }

    pub fn get_params(&self) -> &[TypeVarWithKind] {
        &self.params
    }

    // .daml_lf_1.DefDataType.Fields record = 3;

    pub fn clear_record(&mut self) {
        self.DataCons = ::std::option::Option::None;
    }

    pub fn has_record(&self) -> bool {
        match self.DataCons {
            ::std::option::Option::Some(DefDataType_oneof_DataCons::record(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_record(&mut self, v: DefDataType_Fields) {
        self.DataCons = ::std::option::Option::Some(DefDataType_oneof_DataCons::record(v))
    }

    // Mutable pointer to the field.
    pub fn mut_record(&mut self) -> &mut DefDataType_Fields {
        if let ::std::option::Option::Some(DefDataType_oneof_DataCons::record(_)) = self.DataCons {
        } else {
            self.DataCons = ::std::option::Option::Some(DefDataType_oneof_DataCons::record(DefDataType_Fields::new()));
        }
        match self.DataCons {
            ::std::option::Option::Some(DefDataType_oneof_DataCons::record(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_record(&mut self) -> DefDataType_Fields {
        if self.has_record() {
            match self.DataCons.take() {
                ::std::option::Option::Some(DefDataType_oneof_DataCons::record(v)) => v,
                _ => panic!(),
            }
        } else {
            DefDataType_Fields::new()
        }
    }

    pub fn get_record(&self) -> &DefDataType_Fields {
        match self.DataCons {
            ::std::option::Option::Some(DefDataType_oneof_DataCons::record(ref v)) => v,
            _ => DefDataType_Fields::default_instance(),
        }
    }

    // .daml_lf_1.DefDataType.Fields variant = 4;

    pub fn clear_variant(&mut self) {
        self.DataCons = ::std::option::Option::None;
    }

    pub fn has_variant(&self) -> bool {
        match self.DataCons {
            ::std::option::Option::Some(DefDataType_oneof_DataCons::variant(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_variant(&mut self, v: DefDataType_Fields) {
        self.DataCons = ::std::option::Option::Some(DefDataType_oneof_DataCons::variant(v))
    }

    // Mutable pointer to the field.
    pub fn mut_variant(&mut self) -> &mut DefDataType_Fields {
        if let ::std::option::Option::Some(DefDataType_oneof_DataCons::variant(_)) = self.DataCons {
        } else {
            self.DataCons = ::std::option::Option::Some(DefDataType_oneof_DataCons::variant(DefDataType_Fields::new()));
        }
        match self.DataCons {
            ::std::option::Option::Some(DefDataType_oneof_DataCons::variant(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_variant(&mut self) -> DefDataType_Fields {
        if self.has_variant() {
            match self.DataCons.take() {
                ::std::option::Option::Some(DefDataType_oneof_DataCons::variant(v)) => v,
                _ => panic!(),
            }
        } else {
            DefDataType_Fields::new()
        }
    }

    pub fn get_variant(&self) -> &DefDataType_Fields {
        match self.DataCons {
            ::std::option::Option::Some(DefDataType_oneof_DataCons::variant(ref v)) => v,
            _ => DefDataType_Fields::default_instance(),
        }
    }

    // bool serializable = 5;

    pub fn clear_serializable(&mut self) {
        self.serializable = false;
    }

    // Param is passed by value, moved
    pub fn set_serializable(&mut self, v: bool) {
        self.serializable = v;
    }

    pub fn get_serializable(&self) -> bool {
        self.serializable
    }

    // .daml_lf_1.Location location = 6;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Location) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut Location {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> Location {
        self.location.take().unwrap_or_else(|| Location::new())
    }

    pub fn get_location(&self) -> &Location {
        self.location.as_ref().unwrap_or_else(|| Location::default_instance())
    }
}

impl ::protobuf::Message for DefDataType {
    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(DefDataType_oneof_DataCons::record(ref v)) = self.DataCons {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DefDataType_oneof_DataCons::variant(ref v)) = self.DataCons {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.params)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DataCons = ::std::option::Option::Some(DefDataType_oneof_DataCons::record(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.DataCons = ::std::option::Option::Some(DefDataType_oneof_DataCons::variant(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.serializable = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.serializable != false {
            my_size += 2;
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.DataCons {
            match v {
                &DefDataType_oneof_DataCons::record(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DefDataType_oneof_DataCons::variant(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.params {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.serializable != false {
            os.write_bool(5, self.serializable)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.DataCons {
            match v {
                &DefDataType_oneof_DataCons::record(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DefDataType_oneof_DataCons::variant(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefDataType {
        DefDataType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DottedName>>(
                    "name",
                    |m: &DefDataType| { &m.name },
                    |m: &mut DefDataType| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypeVarWithKind>>(
                    "params",
                    |m: &DefDataType| { &m.params },
                    |m: &mut DefDataType| { &mut m.params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefDataType_Fields>(
                    "record",
                    DefDataType::has_record,
                    DefDataType::get_record,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DefDataType_Fields>(
                    "variant",
                    DefDataType::has_variant,
                    DefDataType::get_variant,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "serializable",
                    |m: &DefDataType| { &m.serializable },
                    |m: &mut DefDataType| { &mut m.serializable },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Location>>(
                    "location",
                    |m: &DefDataType| { &m.location },
                    |m: &mut DefDataType| { &mut m.location },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DefDataType>(
                    "DefDataType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefDataType {
        static mut instance: ::protobuf::lazy::Lazy<DefDataType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefDataType,
        };
        unsafe {
            instance.get(DefDataType::new)
        }
    }
}

impl ::protobuf::Clear for DefDataType {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_params();
        self.clear_record();
        self.clear_variant();
        self.clear_serializable();
        self.clear_location();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefDataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefDataType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefDataType_Fields {
    // message fields
    pub fields: ::protobuf::RepeatedField<FieldWithType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DefDataType_Fields {
    pub fn new() -> DefDataType_Fields {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.FieldWithType fields = 1;

    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<FieldWithType>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<FieldWithType> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<FieldWithType> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }

    pub fn get_fields(&self) -> &[FieldWithType] {
        &self.fields
    }
}

impl ::protobuf::Message for DefDataType_Fields {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefDataType_Fields {
        DefDataType_Fields::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldWithType>>(
                    "fields",
                    |m: &DefDataType_Fields| { &m.fields },
                    |m: &mut DefDataType_Fields| { &mut m.fields },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DefDataType_Fields>(
                    "DefDataType_Fields",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefDataType_Fields {
        static mut instance: ::protobuf::lazy::Lazy<DefDataType_Fields> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefDataType_Fields,
        };
        unsafe {
            instance.get(DefDataType_Fields::new)
        }
    }
}

impl ::protobuf::Clear for DefDataType_Fields {
    fn clear(&mut self) {
        self.clear_fields();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefDataType_Fields {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefDataType_Fields {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefValue {
    // message fields
    pub var: ::protobuf::SingularPtrField<VarWithType>,
    pub expr: ::protobuf::SingularPtrField<Expr>,
    pub no_party_literals: bool,
    pub is_test: bool,
    pub location: ::protobuf::SingularPtrField<Location>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DefValue {
    pub fn new() -> DefValue {
        ::std::default::Default::default()
    }

    // .daml_lf_1.VarWithType var = 1;

    pub fn clear_var(&mut self) {
        self.var.clear();
    }

    pub fn has_var(&self) -> bool {
        self.var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var(&mut self, v: VarWithType) {
        self.var = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_var(&mut self) -> &mut VarWithType {
        if self.var.is_none() {
            self.var.set_default();
        }
        self.var.as_mut().unwrap()
    }

    // Take field
    pub fn take_var(&mut self) -> VarWithType {
        self.var.take().unwrap_or_else(|| VarWithType::new())
    }

    pub fn get_var(&self) -> &VarWithType {
        self.var.as_ref().unwrap_or_else(|| VarWithType::default_instance())
    }

    // .daml_lf_1.Expr expr = 2;

    pub fn clear_expr(&mut self) {
        self.expr.clear();
    }

    pub fn has_expr(&self) -> bool {
        self.expr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expr(&mut self, v: Expr) {
        self.expr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expr(&mut self) -> &mut Expr {
        if self.expr.is_none() {
            self.expr.set_default();
        }
        self.expr.as_mut().unwrap()
    }

    // Take field
    pub fn take_expr(&mut self) -> Expr {
        self.expr.take().unwrap_or_else(|| Expr::new())
    }

    pub fn get_expr(&self) -> &Expr {
        self.expr.as_ref().unwrap_or_else(|| Expr::default_instance())
    }

    // bool no_party_literals = 3;

    pub fn clear_no_party_literals(&mut self) {
        self.no_party_literals = false;
    }

    // Param is passed by value, moved
    pub fn set_no_party_literals(&mut self, v: bool) {
        self.no_party_literals = v;
    }

    pub fn get_no_party_literals(&self) -> bool {
        self.no_party_literals
    }

    // bool is_test = 4;

    pub fn clear_is_test(&mut self) {
        self.is_test = false;
    }

    // Param is passed by value, moved
    pub fn set_is_test(&mut self, v: bool) {
        self.is_test = v;
    }

    pub fn get_is_test(&self) -> bool {
        self.is_test
    }

    // .daml_lf_1.Location location = 5;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Location) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut Location {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> Location {
        self.location.take().unwrap_or_else(|| Location::new())
    }

    pub fn get_location(&self) -> &Location {
        self.location.as_ref().unwrap_or_else(|| Location::default_instance())
    }
}

impl ::protobuf::Message for DefValue {
    fn is_initialized(&self) -> bool {
        for v in &self.var {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.var)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expr)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_party_literals = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_test = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.var.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.no_party_literals != false {
            my_size += 2;
        }
        if self.is_test != false {
            my_size += 2;
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.var.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.no_party_literals != false {
            os.write_bool(3, self.no_party_literals)?;
        }
        if self.is_test != false {
            os.write_bool(4, self.is_test)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefValue {
        DefValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VarWithType>>(
                    "var",
                    |m: &DefValue| { &m.var },
                    |m: &mut DefValue| { &mut m.var },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Expr>>(
                    "expr",
                    |m: &DefValue| { &m.expr },
                    |m: &mut DefValue| { &mut m.expr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "no_party_literals",
                    |m: &DefValue| { &m.no_party_literals },
                    |m: &mut DefValue| { &mut m.no_party_literals },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_test",
                    |m: &DefValue| { &m.is_test },
                    |m: &mut DefValue| { &mut m.is_test },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Location>>(
                    "location",
                    |m: &DefValue| { &m.location },
                    |m: &mut DefValue| { &mut m.location },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DefValue>(
                    "DefValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefValue {
        static mut instance: ::protobuf::lazy::Lazy<DefValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefValue,
        };
        unsafe {
            instance.get(DefValue::new)
        }
    }
}

impl ::protobuf::Clear for DefValue {
    fn clear(&mut self) {
        self.clear_var();
        self.clear_expr();
        self.clear_no_party_literals();
        self.clear_is_test();
        self.clear_location();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeatureFlags {
    // message fields
    pub forbidPartyLiterals: bool,
    pub dontDivulgeContractIdsInCreateArguments: bool,
    pub dontDiscloseNonConsumingChoicesToObservers: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl FeatureFlags {
    pub fn new() -> FeatureFlags {
        ::std::default::Default::default()
    }

    // bool forbidPartyLiterals = 1;

    pub fn clear_forbidPartyLiterals(&mut self) {
        self.forbidPartyLiterals = false;
    }

    // Param is passed by value, moved
    pub fn set_forbidPartyLiterals(&mut self, v: bool) {
        self.forbidPartyLiterals = v;
    }

    pub fn get_forbidPartyLiterals(&self) -> bool {
        self.forbidPartyLiterals
    }

    // bool dontDivulgeContractIdsInCreateArguments = 2;

    pub fn clear_dontDivulgeContractIdsInCreateArguments(&mut self) {
        self.dontDivulgeContractIdsInCreateArguments = false;
    }

    // Param is passed by value, moved
    pub fn set_dontDivulgeContractIdsInCreateArguments(&mut self, v: bool) {
        self.dontDivulgeContractIdsInCreateArguments = v;
    }

    pub fn get_dontDivulgeContractIdsInCreateArguments(&self) -> bool {
        self.dontDivulgeContractIdsInCreateArguments
    }

    // bool dontDiscloseNonConsumingChoicesToObservers = 3;

    pub fn clear_dontDiscloseNonConsumingChoicesToObservers(&mut self) {
        self.dontDiscloseNonConsumingChoicesToObservers = false;
    }

    // Param is passed by value, moved
    pub fn set_dontDiscloseNonConsumingChoicesToObservers(&mut self, v: bool) {
        self.dontDiscloseNonConsumingChoicesToObservers = v;
    }

    pub fn get_dontDiscloseNonConsumingChoicesToObservers(&self) -> bool {
        self.dontDiscloseNonConsumingChoicesToObservers
    }
}

impl ::protobuf::Message for FeatureFlags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forbidPartyLiterals = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dontDivulgeContractIdsInCreateArguments = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dontDiscloseNonConsumingChoicesToObservers = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.forbidPartyLiterals != false {
            my_size += 2;
        }
        if self.dontDivulgeContractIdsInCreateArguments != false {
            my_size += 2;
        }
        if self.dontDiscloseNonConsumingChoicesToObservers != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.forbidPartyLiterals != false {
            os.write_bool(1, self.forbidPartyLiterals)?;
        }
        if self.dontDivulgeContractIdsInCreateArguments != false {
            os.write_bool(2, self.dontDivulgeContractIdsInCreateArguments)?;
        }
        if self.dontDiscloseNonConsumingChoicesToObservers != false {
            os.write_bool(3, self.dontDiscloseNonConsumingChoicesToObservers)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeatureFlags {
        FeatureFlags::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "forbidPartyLiterals",
                    |m: &FeatureFlags| { &m.forbidPartyLiterals },
                    |m: &mut FeatureFlags| { &mut m.forbidPartyLiterals },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "dontDivulgeContractIdsInCreateArguments",
                    |m: &FeatureFlags| { &m.dontDivulgeContractIdsInCreateArguments },
                    |m: &mut FeatureFlags| { &mut m.dontDivulgeContractIdsInCreateArguments },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "dontDiscloseNonConsumingChoicesToObservers",
                    |m: &FeatureFlags| { &m.dontDiscloseNonConsumingChoicesToObservers },
                    |m: &mut FeatureFlags| { &mut m.dontDiscloseNonConsumingChoicesToObservers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FeatureFlags>(
                    "FeatureFlags",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeatureFlags {
        static mut instance: ::protobuf::lazy::Lazy<FeatureFlags> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeatureFlags,
        };
        unsafe {
            instance.get(FeatureFlags::new)
        }
    }
}

impl ::protobuf::Clear for FeatureFlags {
    fn clear(&mut self) {
        self.clear_forbidPartyLiterals();
        self.clear_dontDivulgeContractIdsInCreateArguments();
        self.clear_dontDiscloseNonConsumingChoicesToObservers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeatureFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Module {
    // message fields
    pub name: ::protobuf::SingularPtrField<DottedName>,
    pub flags: ::protobuf::SingularPtrField<FeatureFlags>,
    pub data_types: ::protobuf::RepeatedField<DefDataType>,
    pub values: ::protobuf::RepeatedField<DefValue>,
    pub templates: ::protobuf::RepeatedField<DefTemplate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    // .daml_lf_1.DottedName name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: DottedName) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut DottedName {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> DottedName {
        self.name.take().unwrap_or_else(|| DottedName::new())
    }

    pub fn get_name(&self) -> &DottedName {
        self.name.as_ref().unwrap_or_else(|| DottedName::default_instance())
    }

    // .daml_lf_1.FeatureFlags flags = 4;

    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: FeatureFlags) {
        self.flags = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&mut self) -> &mut FeatureFlags {
        if self.flags.is_none() {
            self.flags.set_default();
        }
        self.flags.as_mut().unwrap()
    }

    // Take field
    pub fn take_flags(&mut self) -> FeatureFlags {
        self.flags.take().unwrap_or_else(|| FeatureFlags::new())
    }

    pub fn get_flags(&self) -> &FeatureFlags {
        self.flags.as_ref().unwrap_or_else(|| FeatureFlags::default_instance())
    }

    // repeated .daml_lf_1.DefDataType data_types = 5;

    pub fn clear_data_types(&mut self) {
        self.data_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_types(&mut self, v: ::protobuf::RepeatedField<DefDataType>) {
        self.data_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_types(&mut self) -> &mut ::protobuf::RepeatedField<DefDataType> {
        &mut self.data_types
    }

    // Take field
    pub fn take_data_types(&mut self) -> ::protobuf::RepeatedField<DefDataType> {
        ::std::mem::replace(&mut self.data_types, ::protobuf::RepeatedField::new())
    }

    pub fn get_data_types(&self) -> &[DefDataType] {
        &self.data_types
    }

    // repeated .daml_lf_1.DefValue values = 6;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<DefValue>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<DefValue> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<DefValue> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    pub fn get_values(&self) -> &[DefValue] {
        &self.values
    }

    // repeated .daml_lf_1.DefTemplate templates = 7;

    pub fn clear_templates(&mut self) {
        self.templates.clear();
    }

    // Param is passed by value, moved
    pub fn set_templates(&mut self, v: ::protobuf::RepeatedField<DefTemplate>) {
        self.templates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_templates(&mut self) -> &mut ::protobuf::RepeatedField<DefTemplate> {
        &mut self.templates
    }

    // Take field
    pub fn take_templates(&mut self) -> ::protobuf::RepeatedField<DefTemplate> {
        ::std::mem::replace(&mut self.templates, ::protobuf::RepeatedField::new())
    }

    pub fn get_templates(&self) -> &[DefTemplate] {
        &self.templates
    }
}

impl ::protobuf::Message for Module {
    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data_types {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.templates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flags)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_types)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.templates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flags.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.data_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.templates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flags.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.data_types {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.values {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.templates {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Module {
        Module::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DottedName>>(
                    "name",
                    |m: &Module| { &m.name },
                    |m: &mut Module| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeatureFlags>>(
                    "flags",
                    |m: &Module| { &m.flags },
                    |m: &mut Module| { &mut m.flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefDataType>>(
                    "data_types",
                    |m: &Module| { &m.data_types },
                    |m: &mut Module| { &mut m.data_types },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefValue>>(
                    "values",
                    |m: &Module| { &m.values },
                    |m: &mut Module| { &mut m.values },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefTemplate>>(
                    "templates",
                    |m: &Module| { &m.templates },
                    |m: &mut Module| { &mut m.templates },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Module>(
                    "Module",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Module {
        static mut instance: ::protobuf::lazy::Lazy<Module> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Module,
        };
        unsafe {
            instance.get(Module::new)
        }
    }
}

impl ::protobuf::Clear for Module {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_flags();
        self.clear_data_types();
        self.clear_values();
        self.clear_templates();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Package {
    // message fields
    pub modules: ::protobuf::RepeatedField<Module>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Package {
    pub fn new() -> Package {
        ::std::default::Default::default()
    }

    // repeated .daml_lf_1.Module modules = 1;

    pub fn clear_modules(&mut self) {
        self.modules.clear();
    }

    // Param is passed by value, moved
    pub fn set_modules(&mut self, v: ::protobuf::RepeatedField<Module>) {
        self.modules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modules(&mut self) -> &mut ::protobuf::RepeatedField<Module> {
        &mut self.modules
    }

    // Take field
    pub fn take_modules(&mut self) -> ::protobuf::RepeatedField<Module> {
        ::std::mem::replace(&mut self.modules, ::protobuf::RepeatedField::new())
    }

    pub fn get_modules(&self) -> &[Module] {
        &self.modules
    }
}

impl ::protobuf::Message for Package {
    fn is_initialized(&self) -> bool {
        for v in &self.modules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modules)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.modules {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Package {
        Package::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Module>>(
                    "modules",
                    |m: &Package| { &m.modules },
                    |m: &mut Package| { &mut m.modules },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Package>(
                    "Package",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Package {
        static mut instance: ::protobuf::lazy::Lazy<Package> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Package,
        };
        unsafe {
            instance.get(Package::new)
        }
    }
}

impl ::protobuf::Clear for Package {
    fn clear(&mut self) {
        self.clear_modules();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Package {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Package {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PrimType {
    UNIT = 0,
    BOOL = 1,
    INT64 = 2,
    DECIMAL = 3,
    TEXT = 5,
    TIMESTAMP = 6,
    PARTY = 8,
    LIST = 9,
    UPDATE = 10,
    SCENARIO = 11,
    DATE = 12,
    CONTRACT_ID = 13,
}

impl ::protobuf::ProtobufEnum for PrimType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrimType> {
        match value {
            0 => ::std::option::Option::Some(PrimType::UNIT),
            1 => ::std::option::Option::Some(PrimType::BOOL),
            2 => ::std::option::Option::Some(PrimType::INT64),
            3 => ::std::option::Option::Some(PrimType::DECIMAL),
            5 => ::std::option::Option::Some(PrimType::TEXT),
            6 => ::std::option::Option::Some(PrimType::TIMESTAMP),
            8 => ::std::option::Option::Some(PrimType::PARTY),
            9 => ::std::option::Option::Some(PrimType::LIST),
            10 => ::std::option::Option::Some(PrimType::UPDATE),
            11 => ::std::option::Option::Some(PrimType::SCENARIO),
            12 => ::std::option::Option::Some(PrimType::DATE),
            13 => ::std::option::Option::Some(PrimType::CONTRACT_ID),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PrimType] = &[
            PrimType::UNIT,
            PrimType::BOOL,
            PrimType::INT64,
            PrimType::DECIMAL,
            PrimType::TEXT,
            PrimType::TIMESTAMP,
            PrimType::PARTY,
            PrimType::LIST,
            PrimType::UPDATE,
            PrimType::SCENARIO,
            PrimType::DATE,
            PrimType::CONTRACT_ID,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PrimType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PrimType {
}

impl ::std::default::Default for PrimType {
    fn default() -> Self {
        PrimType::UNIT
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PrimCon {
    CON_UNIT = 0,
    CON_FALSE = 1,
    CON_TRUE = 2,
}

impl ::protobuf::ProtobufEnum for PrimCon {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrimCon> {
        match value {
            0 => ::std::option::Option::Some(PrimCon::CON_UNIT),
            1 => ::std::option::Option::Some(PrimCon::CON_FALSE),
            2 => ::std::option::Option::Some(PrimCon::CON_TRUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PrimCon] = &[
            PrimCon::CON_UNIT,
            PrimCon::CON_FALSE,
            PrimCon::CON_TRUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PrimCon", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PrimCon {
}

impl ::std::default::Default for PrimCon {
    fn default() -> Self {
        PrimCon::CON_UNIT
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimCon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BuiltinFunction {
    ADD_DECIMAL = 0,
    SUB_DECIMAL = 1,
    MUL_DECIMAL = 2,
    DIV_DECIMAL = 3,
    ROUND_DECIMAL = 6,
    ADD_INT64 = 7,
    SUB_INT64 = 8,
    MUL_INT64 = 9,
    DIV_INT64 = 10,
    MOD_INT64 = 11,
    EXP_INT64 = 12,
    FOLDL = 20,
    FOLDR = 21,
    EXPLODE_TEXT = 23,
    APPEND_TEXT = 24,
    ERROR = 25,
    LEQ_INT64 = 33,
    LEQ_DECIMAL = 34,
    LEQ_TEXT = 36,
    LEQ_TIMESTAMP = 37,
    LEQ_DATE = 67,
    LESS_INT64 = 39,
    LESS_DECIMAL = 40,
    LESS_TEXT = 42,
    LESS_TIMESTAMP = 43,
    LESS_DATE = 68,
    GEQ_INT64 = 45,
    GEQ_DECIMAL = 46,
    GEQ_TEXT = 48,
    GEQ_TIMESTAMP = 49,
    GEQ_DATE = 69,
    GREATER_INT64 = 51,
    GREATER_DECIMAL = 52,
    GREATER_TEXT = 54,
    GREATER_TIMESTAMP = 55,
    GREATER_DATE = 70,
    TO_TEXT_INT64 = 57,
    TO_TEXT_DECIMAL = 58,
    TO_TEXT_TEXT = 60,
    TO_TEXT_TIMESTAMP = 61,
    TO_TEXT_DATE = 71,
    TO_TEXT_PARTY = 63,
    DATE_TO_UNIX_DAYS = 72,
    UNIX_DAYS_TO_DATE = 73,
    TIMESTAMP_TO_UNIX_MICROSECONDS = 74,
    UNIX_MICROSECONDS_TO_TIMESTAMP = 75,
    INT64_TO_DECIMAL = 76,
    DECIMAL_TO_INT64 = 77,
    IMPLODE_TEXT = 78,
    EQUAL_INT64 = 79,
    EQUAL_DECIMAL = 80,
    EQUAL_TEXT = 81,
    EQUAL_TIMESTAMP = 82,
    EQUAL_DATE = 83,
    EQUAL_PARTY = 84,
    EQUAL_BOOL = 85,
    EQUAL_CONTRACT_ID = 86,
    EQUAL_LIST = 87,
    TRACE = 88,
}

impl ::protobuf::ProtobufEnum for BuiltinFunction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BuiltinFunction> {
        match value {
            0 => ::std::option::Option::Some(BuiltinFunction::ADD_DECIMAL),
            1 => ::std::option::Option::Some(BuiltinFunction::SUB_DECIMAL),
            2 => ::std::option::Option::Some(BuiltinFunction::MUL_DECIMAL),
            3 => ::std::option::Option::Some(BuiltinFunction::DIV_DECIMAL),
            6 => ::std::option::Option::Some(BuiltinFunction::ROUND_DECIMAL),
            7 => ::std::option::Option::Some(BuiltinFunction::ADD_INT64),
            8 => ::std::option::Option::Some(BuiltinFunction::SUB_INT64),
            9 => ::std::option::Option::Some(BuiltinFunction::MUL_INT64),
            10 => ::std::option::Option::Some(BuiltinFunction::DIV_INT64),
            11 => ::std::option::Option::Some(BuiltinFunction::MOD_INT64),
            12 => ::std::option::Option::Some(BuiltinFunction::EXP_INT64),
            20 => ::std::option::Option::Some(BuiltinFunction::FOLDL),
            21 => ::std::option::Option::Some(BuiltinFunction::FOLDR),
            23 => ::std::option::Option::Some(BuiltinFunction::EXPLODE_TEXT),
            24 => ::std::option::Option::Some(BuiltinFunction::APPEND_TEXT),
            25 => ::std::option::Option::Some(BuiltinFunction::ERROR),
            33 => ::std::option::Option::Some(BuiltinFunction::LEQ_INT64),
            34 => ::std::option::Option::Some(BuiltinFunction::LEQ_DECIMAL),
            36 => ::std::option::Option::Some(BuiltinFunction::LEQ_TEXT),
            37 => ::std::option::Option::Some(BuiltinFunction::LEQ_TIMESTAMP),
            67 => ::std::option::Option::Some(BuiltinFunction::LEQ_DATE),
            39 => ::std::option::Option::Some(BuiltinFunction::LESS_INT64),
            40 => ::std::option::Option::Some(BuiltinFunction::LESS_DECIMAL),
            42 => ::std::option::Option::Some(BuiltinFunction::LESS_TEXT),
            43 => ::std::option::Option::Some(BuiltinFunction::LESS_TIMESTAMP),
            68 => ::std::option::Option::Some(BuiltinFunction::LESS_DATE),
            45 => ::std::option::Option::Some(BuiltinFunction::GEQ_INT64),
            46 => ::std::option::Option::Some(BuiltinFunction::GEQ_DECIMAL),
            48 => ::std::option::Option::Some(BuiltinFunction::GEQ_TEXT),
            49 => ::std::option::Option::Some(BuiltinFunction::GEQ_TIMESTAMP),
            69 => ::std::option::Option::Some(BuiltinFunction::GEQ_DATE),
            51 => ::std::option::Option::Some(BuiltinFunction::GREATER_INT64),
            52 => ::std::option::Option::Some(BuiltinFunction::GREATER_DECIMAL),
            54 => ::std::option::Option::Some(BuiltinFunction::GREATER_TEXT),
            55 => ::std::option::Option::Some(BuiltinFunction::GREATER_TIMESTAMP),
            70 => ::std::option::Option::Some(BuiltinFunction::GREATER_DATE),
            57 => ::std::option::Option::Some(BuiltinFunction::TO_TEXT_INT64),
            58 => ::std::option::Option::Some(BuiltinFunction::TO_TEXT_DECIMAL),
            60 => ::std::option::Option::Some(BuiltinFunction::TO_TEXT_TEXT),
            61 => ::std::option::Option::Some(BuiltinFunction::TO_TEXT_TIMESTAMP),
            71 => ::std::option::Option::Some(BuiltinFunction::TO_TEXT_DATE),
            63 => ::std::option::Option::Some(BuiltinFunction::TO_TEXT_PARTY),
            72 => ::std::option::Option::Some(BuiltinFunction::DATE_TO_UNIX_DAYS),
            73 => ::std::option::Option::Some(BuiltinFunction::UNIX_DAYS_TO_DATE),
            74 => ::std::option::Option::Some(BuiltinFunction::TIMESTAMP_TO_UNIX_MICROSECONDS),
            75 => ::std::option::Option::Some(BuiltinFunction::UNIX_MICROSECONDS_TO_TIMESTAMP),
            76 => ::std::option::Option::Some(BuiltinFunction::INT64_TO_DECIMAL),
            77 => ::std::option::Option::Some(BuiltinFunction::DECIMAL_TO_INT64),
            78 => ::std::option::Option::Some(BuiltinFunction::IMPLODE_TEXT),
            79 => ::std::option::Option::Some(BuiltinFunction::EQUAL_INT64),
            80 => ::std::option::Option::Some(BuiltinFunction::EQUAL_DECIMAL),
            81 => ::std::option::Option::Some(BuiltinFunction::EQUAL_TEXT),
            82 => ::std::option::Option::Some(BuiltinFunction::EQUAL_TIMESTAMP),
            83 => ::std::option::Option::Some(BuiltinFunction::EQUAL_DATE),
            84 => ::std::option::Option::Some(BuiltinFunction::EQUAL_PARTY),
            85 => ::std::option::Option::Some(BuiltinFunction::EQUAL_BOOL),
            86 => ::std::option::Option::Some(BuiltinFunction::EQUAL_CONTRACT_ID),
            87 => ::std::option::Option::Some(BuiltinFunction::EQUAL_LIST),
            88 => ::std::option::Option::Some(BuiltinFunction::TRACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BuiltinFunction] = &[
            BuiltinFunction::ADD_DECIMAL,
            BuiltinFunction::SUB_DECIMAL,
            BuiltinFunction::MUL_DECIMAL,
            BuiltinFunction::DIV_DECIMAL,
            BuiltinFunction::ROUND_DECIMAL,
            BuiltinFunction::ADD_INT64,
            BuiltinFunction::SUB_INT64,
            BuiltinFunction::MUL_INT64,
            BuiltinFunction::DIV_INT64,
            BuiltinFunction::MOD_INT64,
            BuiltinFunction::EXP_INT64,
            BuiltinFunction::FOLDL,
            BuiltinFunction::FOLDR,
            BuiltinFunction::EXPLODE_TEXT,
            BuiltinFunction::APPEND_TEXT,
            BuiltinFunction::ERROR,
            BuiltinFunction::LEQ_INT64,
            BuiltinFunction::LEQ_DECIMAL,
            BuiltinFunction::LEQ_TEXT,
            BuiltinFunction::LEQ_TIMESTAMP,
            BuiltinFunction::LEQ_DATE,
            BuiltinFunction::LESS_INT64,
            BuiltinFunction::LESS_DECIMAL,
            BuiltinFunction::LESS_TEXT,
            BuiltinFunction::LESS_TIMESTAMP,
            BuiltinFunction::LESS_DATE,
            BuiltinFunction::GEQ_INT64,
            BuiltinFunction::GEQ_DECIMAL,
            BuiltinFunction::GEQ_TEXT,
            BuiltinFunction::GEQ_TIMESTAMP,
            BuiltinFunction::GEQ_DATE,
            BuiltinFunction::GREATER_INT64,
            BuiltinFunction::GREATER_DECIMAL,
            BuiltinFunction::GREATER_TEXT,
            BuiltinFunction::GREATER_TIMESTAMP,
            BuiltinFunction::GREATER_DATE,
            BuiltinFunction::TO_TEXT_INT64,
            BuiltinFunction::TO_TEXT_DECIMAL,
            BuiltinFunction::TO_TEXT_TEXT,
            BuiltinFunction::TO_TEXT_TIMESTAMP,
            BuiltinFunction::TO_TEXT_DATE,
            BuiltinFunction::TO_TEXT_PARTY,
            BuiltinFunction::DATE_TO_UNIX_DAYS,
            BuiltinFunction::UNIX_DAYS_TO_DATE,
            BuiltinFunction::TIMESTAMP_TO_UNIX_MICROSECONDS,
            BuiltinFunction::UNIX_MICROSECONDS_TO_TIMESTAMP,
            BuiltinFunction::INT64_TO_DECIMAL,
            BuiltinFunction::DECIMAL_TO_INT64,
            BuiltinFunction::IMPLODE_TEXT,
            BuiltinFunction::EQUAL_INT64,
            BuiltinFunction::EQUAL_DECIMAL,
            BuiltinFunction::EQUAL_TEXT,
            BuiltinFunction::EQUAL_TIMESTAMP,
            BuiltinFunction::EQUAL_DATE,
            BuiltinFunction::EQUAL_PARTY,
            BuiltinFunction::EQUAL_BOOL,
            BuiltinFunction::EQUAL_CONTRACT_ID,
            BuiltinFunction::EQUAL_LIST,
            BuiltinFunction::TRACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BuiltinFunction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BuiltinFunction {
}

impl ::std::default::Default for BuiltinFunction {
    fn default() -> Self {
        BuiltinFunction::ADD_DECIMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for BuiltinFunction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fdaml_lf_1.proto\x12\tdaml_lf_1\"\x06\n\x04Unit\"[\n\nPackageRef\
    \x12%\n\x04self\x18\x01\x20\x01(\x0b2\x0f.daml_lf_1.UnitH\0R\x04self\x12\
    \x1f\n\npackage_id\x18\x02\x20\x01(\tH\0R\tpackageIdB\x05\n\x03Sum\"(\n\
    \nDottedName\x12\x1a\n\x08segments\x18\x01\x20\x03(\tR\x08segments\"{\n\
    \tModuleRef\x126\n\x0bpackage_ref\x18\x01\x20\x01(\x0b2\x15.daml_lf_1.Pa\
    ckageRefR\npackageRef\x126\n\x0bmodule_name\x18\x02\x20\x01(\x0b2\x15.da\
    ml_lf_1.DottedNameR\nmoduleName\"f\n\x0bTypeConName\x12,\n\x06module\x18\
    \x01\x20\x01(\x0b2\x14.daml_lf_1.ModuleRefR\x06module\x12)\n\x04name\x18\
    \x02\x20\x01(\x0b2\x15.daml_lf_1.DottedNameR\x04name\"K\n\x07ValName\x12\
    ,\n\x06module\x18\x01\x20\x01(\x0b2\x14.daml_lf_1.ModuleRefR\x06module\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"J\n\rFieldWithType\x12\
    \x14\n\x05field\x18\x01\x20\x01(\tR\x05field\x12#\n\x04type\x18\x02\x20\
    \x01(\x0b2\x0f.daml_lf_1.TypeR\x04type\"D\n\x0bVarWithType\x12\x10\n\x03\
    var\x18\x01\x20\x01(\tR\x03var\x12#\n\x04type\x18\x02\x20\x01(\x0b2\x0f.\
    daml_lf_1.TypeR\x04type\"H\n\x0fTypeVarWithKind\x12\x10\n\x03var\x18\x01\
    \x20\x01(\tR\x03var\x12#\n\x04kind\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.K\
    indR\x04kind\"J\n\rFieldWithExpr\x12\x14\n\x05field\x18\x01\x20\x01(\tR\
    \x05field\x12#\n\x04expr\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x04ex\
    pr\"`\n\x07Binding\x12.\n\x06binder\x18\x01\x20\x01(\x0b2\x16.daml_lf_1.\
    VarWithTypeR\x06binder\x12%\n\x05bound\x18\x02\x20\x01(\x0b2\x0f.daml_lf\
    _1.ExprR\x05bound\"\xbe\x01\n\x04Kind\x12%\n\x04star\x18\x01\x20\x01(\
    \x0b2\x0f.daml_lf_1.UnitH\0R\x04star\x12-\n\x05arrow\x18\x02\x20\x01(\
    \x0b2\x15.daml_lf_1.Kind.ArrowH\0R\x05arrow\x1aY\n\x05Arrow\x12'\n\x06pa\
    rams\x18\x01\x20\x03(\x0b2\x0f.daml_lf_1.KindR\x06params\x12'\n\x06resul\
    t\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.KindR\x06resultB\x05\n\x03Sum\"\
    \xe1\x06\n\x04Type\x12'\n\x03var\x18\x01\x20\x01(\x0b2\x13.daml_lf_1.Typ\
    e.VarH\0R\x03var\x12'\n\x03con\x18\x02\x20\x01(\x0b2\x13.daml_lf_1.Type.\
    ConH\0R\x03con\x12*\n\x04prim\x18\x03\x20\x01(\x0b2\x14.daml_lf_1.Type.P\
    rimH\0R\x04prim\x12'\n\x03fun\x18\x04\x20\x01(\x0b2\x13.daml_lf_1.Type.F\
    unH\0R\x03fun\x120\n\x06forall\x18\x05\x20\x01(\x0b2\x16.daml_lf_1.Type.\
    ForallH\0R\x06forall\x12-\n\x05tuple\x18\x07\x20\x01(\x0b2\x15.daml_lf_1\
    .Type.TupleH\0R\x05tuple\x1a<\n\x03Var\x12\x10\n\x03var\x18\x01\x20\x01(\
    \tR\x03var\x12#\n\x04args\x18\x02\x20\x03(\x0b2\x0f.daml_lf_1.TypeR\x04a\
    rgs\x1aX\n\x03Con\x12,\n\x05tycon\x18\x01\x20\x01(\x0b2\x16.daml_lf_1.Ty\
    peConNameR\x05tycon\x12#\n\x04args\x18\x02\x20\x03(\x0b2\x0f.daml_lf_1.T\
    ypeR\x04args\x1aT\n\x04Prim\x12'\n\x04prim\x18\x01\x20\x01(\x0e2\x13.dam\
    l_lf_1.PrimTypeR\x04prim\x12#\n\x04args\x18\x02\x20\x03(\x0b2\x0f.daml_l\
    f_1.TypeR\x04args\x1aW\n\x03Fun\x12'\n\x06params\x18\x01\x20\x03(\x0b2\
    \x0f.daml_lf_1.TypeR\x06params\x12'\n\x06result\x18\x02\x20\x01(\x0b2\
    \x0f.daml_lf_1.TypeR\x06result\x1a]\n\x06Forall\x12.\n\x04vars\x18\x01\
    \x20\x03(\x0b2\x1a.daml_lf_1.TypeVarWithKindR\x04vars\x12#\n\x04body\x18\
    \x02\x20\x01(\x0b2\x0f.daml_lf_1.TypeR\x04body\x1a9\n\x05Tuple\x120\n\
    \x06fields\x18\x01\x20\x03(\x0b2\x18.daml_lf_1.FieldWithTypeR\x06fields\
    \x1aQ\n\x03App\x12%\n\x05tyfun\x18\x01\x20\x01(\x0b2\x0f.daml_lf_1.TypeR\
    \x05tyfun\x12#\n\x04args\x18\x02\x20\x03(\x0b2\x0f.daml_lf_1.TypeR\x04ar\
    gsB\x05\n\x03SumJ\x04\x08\x06\x10\x07J\x04\x08\x08\x10\tJ\x04\x08\t\x10\
    \nJ\x04\x08\n\x10\x0b\"\xb4\x01\n\x07PrimLit\x12\x16\n\x05int64\x18\x01\
    \x20\x01(\x12H\0R\x05int64\x12\x1a\n\x07decimal\x18\x02\x20\x01(\tH\0R\
    \x07decimal\x12\x14\n\x04text\x18\x04\x20\x01(\tH\0R\x04text\x12\x1e\n\t\
    timestamp\x18\x05\x20\x01(\x10H\0R\ttimestamp\x12\x16\n\x05party\x18\x07\
    \x20\x01(\tH\0R\x05party\x12\x14\n\x04date\x18\x08\x20\x01(\x05H\0R\x04d\
    ateB\x05\n\x03SumJ\x04\x08\x03\x10\x04J\x04\x08\x06\x10\x07\"\xe2\x01\n\
    \x08Location\x12,\n\x06module\x18\x01\x20\x01(\x0b2\x14.daml_lf_1.Module\
    RefR\x06module\x12/\n\x05range\x18\x02\x20\x01(\x0b2\x19.daml_lf_1.Locat\
    ion.RangeR\x05range\x1aw\n\x05Range\x12\x1d\n\nstart_line\x18\x01\x20\
    \x01(\x05R\tstartLine\x12\x1b\n\tstart_col\x18\x02\x20\x01(\x05R\x08star\
    tCol\x12\x19\n\x08end_line\x18\x03\x20\x01(\x05R\x07endLine\x12\x17\n\
    \x07end_col\x18\x04\x20\x01(\x05R\x06endCol\"\xe1\x12\n\x04Expr\x12/\n\
    \x08location\x18\x19\x20\x01(\x0b2\x13.daml_lf_1.LocationR\x08location\
    \x12\x12\n\x03var\x18\x01\x20\x01(\tH\0R\x03var\x12&\n\x03val\x18\x02\
    \x20\x01(\x0b2\x12.daml_lf_1.ValNameH\0R\x03val\x126\n\x07builtin\x18\
    \x03\x20\x01(\x0e2\x1a.daml_lf_1.BuiltinFunctionH\0R\x07builtin\x12/\n\
    \x08prim_con\x18\x04\x20\x01(\x0e2\x12.daml_lf_1.PrimConH\0R\x07primCon\
    \x12/\n\x08prim_lit\x18\x05\x20\x01(\x0b2\x12.daml_lf_1.PrimLitH\0R\x07p\
    rimLit\x121\n\x07rec_con\x18\x06\x20\x01(\x0b2\x16.daml_lf_1.Expr.RecCon\
    H\0R\x06recCon\x124\n\x08rec_proj\x18\x07\x20\x01(\x0b2\x17.daml_lf_1.Ex\
    pr.RecProjH\0R\x07recProj\x12=\n\x0bvariant_con\x18\x08\x20\x01(\x0b2\
    \x1a.daml_lf_1.Expr.VariantConH\0R\nvariantCon\x127\n\ttuple_con\x18\t\
    \x20\x01(\x0b2\x18.daml_lf_1.Expr.TupleConH\0R\x08tupleCon\x12:\n\ntuple\
    _proj\x18\n\x20\x01(\x0b2\x19.daml_lf_1.Expr.TupleProjH\0R\ttupleProj\
    \x12'\n\x03app\x18\x0b\x20\x01(\x0b2\x13.daml_lf_1.Expr.AppH\0R\x03app\
    \x12.\n\x06ty_app\x18\x0c\x20\x01(\x0b2\x15.daml_lf_1.Expr.TyAppH\0R\x05\
    tyApp\x12'\n\x03abs\x18\r\x20\x01(\x0b2\x13.daml_lf_1.Expr.AbsH\0R\x03ab\
    s\x12.\n\x06ty_abs\x18\x0e\x20\x01(\x0b2\x15.daml_lf_1.Expr.TyAbsH\0R\
    \x05tyAbs\x12%\n\x04case\x18\x0f\x20\x01(\x0b2\x0f.daml_lf_1.CaseH\0R\
    \x04case\x12$\n\x03let\x18\x10\x20\x01(\x0b2\x10.daml_lf_1.BlockH\0R\x03\
    let\x12'\n\x03nil\x18\x11\x20\x01(\x0b2\x13.daml_lf_1.Expr.NilH\0R\x03ni\
    l\x12*\n\x04cons\x18\x12\x20\x01(\x0b2\x14.daml_lf_1.Expr.ConsH\0R\x04co\
    ns\x12+\n\x06update\x18\x14\x20\x01(\x0b2\x11.daml_lf_1.UpdateH\0R\x06up\
    date\x121\n\x08scenario\x18\x15\x20\x01(\x0b2\x13.daml_lf_1.ScenarioH\0R\
    \x08scenario\x121\n\x07rec_upd\x18\x16\x20\x01(\x0b2\x16.daml_lf_1.Expr.\
    RecUpdH\0R\x06recUpd\x127\n\ttuple_upd\x18\x17\x20\x01(\x0b2\x18.daml_lf\
    _1.Expr.TupleUpdH\0R\x08tupleUpd\x1ae\n\x06RecCon\x12)\n\x05tycon\x18\
    \x01\x20\x01(\x0b2\x13.daml_lf_1.Type.ConR\x05tycon\x120\n\x06fields\x18\
    \x02\x20\x03(\x0b2\x18.daml_lf_1.FieldWithExprR\x06fields\x1as\n\x07RecP\
    roj\x12)\n\x05tycon\x18\x01\x20\x01(\x0b2\x13.daml_lf_1.Type.ConR\x05tyc\
    on\x12\x14\n\x05field\x18\x02\x20\x01(\tR\x05field\x12'\n\x06record\x18\
    \x03\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x06record\x1a\x9b\x01\n\x06RecUpd\
    \x12)\n\x05tycon\x18\x01\x20\x01(\x0b2\x13.daml_lf_1.Type.ConR\x05tycon\
    \x12\x14\n\x05field\x18\x02\x20\x01(\tR\x05field\x12'\n\x06record\x18\
    \x03\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x06record\x12'\n\x06update\x18\
    \x04\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x06update\x1a\x8a\x01\n\nVariantC\
    on\x12)\n\x05tycon\x18\x01\x20\x01(\x0b2\x13.daml_lf_1.Type.ConR\x05tyco\
    n\x12\x1f\n\x0bvariant_con\x18\x02\x20\x01(\tR\nvariantCon\x120\n\x0bvar\
    iant_arg\x18\x03\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\nvariantArg\x1a<\n\
    \x08TupleCon\x120\n\x06fields\x18\x01\x20\x03(\x0b2\x18.daml_lf_1.FieldW\
    ithExprR\x06fields\x1aH\n\tTupleProj\x12\x14\n\x05field\x18\x01\x20\x01(\
    \tR\x05field\x12%\n\x05tuple\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\
    \x05tuple\x1ap\n\x08TupleUpd\x12\x14\n\x05field\x18\x01\x20\x01(\tR\x05f\
    ield\x12%\n\x05tuple\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x05tuple\
    \x12'\n\x06update\x18\x03\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x06update\
    \x1aM\n\x03App\x12!\n\x03fun\x18\x01\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\
    \x03fun\x12#\n\x04args\x18\x02\x20\x03(\x0b2\x0f.daml_lf_1.ExprR\x04args\
    \x1aS\n\x05TyApp\x12#\n\x04expr\x18\x01\x20\x01(\x0b2\x0f.daml_lf_1.Expr\
    R\x04expr\x12%\n\x05types\x18\x02\x20\x03(\x0b2\x0f.daml_lf_1.TypeR\x05t\
    ypes\x1aX\n\x03Abs\x12,\n\x05param\x18\x01\x20\x03(\x0b2\x16.daml_lf_1.V\
    arWithTypeR\x05param\x12#\n\x04body\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.\
    ExprR\x04body\x1a^\n\x05TyAbs\x120\n\x05param\x18\x01\x20\x03(\x0b2\x1a.\
    daml_lf_1.TypeVarWithKindR\x05param\x12#\n\x04body\x18\x02\x20\x01(\x0b2\
    \x0f.daml_lf_1.ExprR\x04body\x1a*\n\x03Nil\x12#\n\x04type\x18\x01\x20\
    \x01(\x0b2\x0f.daml_lf_1.TypeR\x04type\x1aw\n\x04Cons\x12#\n\x04type\x18\
    \x01\x20\x01(\x0b2\x0f.daml_lf_1.TypeR\x04type\x12%\n\x05front\x18\x02\
    \x20\x03(\x0b2\x0f.daml_lf_1.ExprR\x05front\x12#\n\x04tail\x18\x03\x20\
    \x01(\x0b2\x0f.daml_lf_1.ExprR\x04tailB\x05\n\x03SumJ\x04\x08\x13\x10\
    \x14J\x04\x08\x18\x10\x19\"\xc4\x03\n\x07CaseAlt\x12+\n\x07default\x18\
    \x01\x20\x01(\x0b2\x0f.daml_lf_1.UnitH\0R\x07default\x126\n\x07variant\
    \x18\x02\x20\x01(\x0b2\x1a.daml_lf_1.CaseAlt.VariantH\0R\x07variant\x12/\
    \n\x08prim_con\x18\x03\x20\x01(\x0e2\x12.daml_lf_1.PrimConH\0R\x07primCo\
    n\x12#\n\x03nil\x18\x04\x20\x01(\x0b2\x0f.daml_lf_1.UnitH\0R\x03nil\x12-\
    \n\x04cons\x18\x05\x20\x01(\x0b2\x17.daml_lf_1.CaseAlt.ConsH\0R\x04cons\
    \x12#\n\x04body\x18\x06\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x04body\x1ae\n\
    \x07Variant\x12(\n\x03con\x18\x01\x20\x01(\x0b2\x16.daml_lf_1.TypeConNam\
    eR\x03con\x12\x18\n\x07variant\x18\x02\x20\x01(\tR\x07variant\x12\x16\n\
    \x06binder\x18\x03\x20\x01(\tR\x06binder\x1a<\n\x04Cons\x12\x19\n\x08var\
    _head\x18\x01\x20\x01(\tR\x07varHead\x12\x19\n\x08var_tail\x18\x02\x20\
    \x01(\tR\x07varTailB\x05\n\x03Sum\"U\n\x04Case\x12%\n\x05scrut\x18\x01\
    \x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x05scrut\x12&\n\x04alts\x18\x02\x20\
    \x03(\x0b2\x12.daml_lf_1.CaseAltR\x04alts\"\\\n\x05Block\x12.\n\x08bindi\
    ngs\x18\x01\x20\x03(\x0b2\x12.daml_lf_1.BindingR\x08bindings\x12#\n\x04b\
    ody\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x04body\"P\n\x04Pure\x12#\
    \n\x04type\x18\x01\x20\x01(\x0b2\x0f.daml_lf_1.TypeR\x04type\x12#\n\x04e\
    xpr\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x04expr\"\xd1\x06\n\x06Upd\
    ate\x12%\n\x04pure\x18\x01\x20\x01(\x0b2\x0f.daml_lf_1.PureH\0R\x04pure\
    \x12(\n\x05block\x18\x02\x20\x01(\x0b2\x10.daml_lf_1.BlockH\0R\x05block\
    \x122\n\x06create\x18\x03\x20\x01(\x0b2\x18.daml_lf_1.Update.CreateH\0R\
    \x06create\x128\n\x08exercise\x18\x04\x20\x01(\x0b2\x1a.daml_lf_1.Update\
    .ExerciseH\0R\x08exercise\x12/\n\x05fetch\x18\x05\x20\x01(\x0b2\x17.daml\
    _lf_1.Update.FetchH\0R\x05fetch\x12,\n\x08get_time\x18\x06\x20\x01(\x0b2\
    \x0f.daml_lf_1.UnitH\0R\x07getTime\x12<\n\nembed_expr\x18\x07\x20\x01(\
    \x0b2\x1b.daml_lf_1.Update.EmbedExprH\0R\tembedExpr\x1aa\n\x06Create\x12\
    2\n\x08template\x18\x01\x20\x01(\x0b2\x16.daml_lf_1.TypeConNameR\x08temp\
    late\x12#\n\x04expr\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x04expr\
    \x1a\xc3\x01\n\x08Exercise\x122\n\x08template\x18\x01\x20\x01(\x0b2\x16.\
    daml_lf_1.TypeConNameR\x08template\x12\x16\n\x06choice\x18\x02\x20\x01(\
    \tR\x06choice\x12!\n\x03cid\x18\x03\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\
    \x03cid\x12%\n\x05actor\x18\x04\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x05act\
    or\x12!\n\x03arg\x18\x05\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x03arg\x1ad\n\
    \x05Fetch\x122\n\x08template\x18\x01\x20\x01(\x0b2\x16.daml_lf_1.TypeCon\
    NameR\x08template\x12!\n\x03cid\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.Expr\
    R\x03cidJ\x04\x08\x03\x10\x04\x1aU\n\tEmbedExpr\x12#\n\x04type\x18\x01\
    \x20\x01(\x0b2\x0f.daml_lf_1.TypeR\x04type\x12#\n\x04body\x18\x02\x20\
    \x01(\x0b2\x0f.daml_lf_1.ExprR\x04bodyB\x05\n\x03Sum\"\x9e\x04\n\x08Scen\
    ario\x12%\n\x04pure\x18\x01\x20\x01(\x0b2\x0f.daml_lf_1.PureH\0R\x04pure\
    \x12(\n\x05block\x18\x02\x20\x01(\x0b2\x10.daml_lf_1.BlockH\0R\x05block\
    \x124\n\x06commit\x18\x03\x20\x01(\x0b2\x1a.daml_lf_1.Scenario.CommitH\0\
    R\x06commit\x12<\n\nmustFailAt\x18\x04\x20\x01(\x0b2\x1a.daml_lf_1.Scena\
    rio.CommitH\0R\nmustFailAt\x12,\n\x08get_time\x18\x06\x20\x01(\x0b2\x0f.\
    daml_lf_1.UnitH\0R\x07getTime\x12>\n\nembed_expr\x18\x08\x20\x01(\x0b2\
    \x1d.daml_lf_1.Scenario.EmbedExprH\0R\tembedExpr\x1a\x80\x01\n\x06Commit\
    \x12%\n\x05party\x18\x01\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x05party\x12#\
    \n\x04expr\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x04expr\x12*\n\x08r\
    et_type\x18\x03\x20\x01(\x0b2\x0f.daml_lf_1.TypeR\x07retType\x1aU\n\tEmb\
    edExpr\x12#\n\x04type\x18\x01\x20\x01(\x0b2\x0f.daml_lf_1.TypeR\x04type\
    \x12#\n\x04body\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x04bodyB\x05\n\
    \x03Sum\"\xd3\x02\n\x0eTemplateChoice\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x1c\n\tconsuming\x18\x02\x20\x01(\x08R\tconsuming\x121\n\
    \x0bcontrollers\x18\x03\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x0bcontrollers\
    \x125\n\narg_binder\x18\x04\x20\x01(\x0b2\x16.daml_lf_1.VarWithTypeR\tar\
    gBinder\x12*\n\x08ret_type\x18\x05\x20\x01(\x0b2\x0f.daml_lf_1.TypeR\x07\
    retType\x12'\n\x06update\x18\x06\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x06up\
    date\x12\x1f\n\x0bself_binder\x18\x07\x20\x01(\tR\nselfBinder\x12/\n\x08\
    location\x18\x08\x20\x01(\x0b2\x13.daml_lf_1.LocationR\x08location\"\xf8\
    \x02\n\x0bDefTemplate\x12+\n\x05tycon\x18\x01\x20\x01(\x0b2\x15.daml_lf_\
    1.DottedNameR\x05tycon\x12\x14\n\x05param\x18\x02\x20\x01(\tR\x05param\
    \x12)\n\x07precond\x18\x04\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x07precond\
    \x121\n\x0bsignatories\x18\x05\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\x0bsign\
    atories\x12-\n\tagreement\x18\x06\x20\x01(\x0b2\x0f.daml_lf_1.ExprR\tagr\
    eement\x123\n\x07choices\x18\x07\x20\x03(\x0b2\x19.daml_lf_1.TemplateCho\
    iceR\x07choices\x12-\n\tobservers\x18\x08\x20\x01(\x0b2\x0f.daml_lf_1.Ex\
    prR\tobservers\x12/\n\x08location\x18\t\x20\x01(\x0b2\x13.daml_lf_1.Loca\
    tionR\x08locationJ\x04\x08\x03\x10\x04\"\xfd\x02\n\x0bDefDataType\x12)\n\
    \x04name\x18\x01\x20\x01(\x0b2\x15.daml_lf_1.DottedNameR\x04name\x122\n\
    \x06params\x18\x02\x20\x03(\x0b2\x1a.daml_lf_1.TypeVarWithKindR\x06param\
    s\x127\n\x06record\x18\x03\x20\x01(\x0b2\x1d.daml_lf_1.DefDataType.Field\
    sH\0R\x06record\x129\n\x07variant\x18\x04\x20\x01(\x0b2\x1d.daml_lf_1.De\
    fDataType.FieldsH\0R\x07variant\x12\"\n\x0cserializable\x18\x05\x20\x01(\
    \x08R\x0cserializable\x12/\n\x08location\x18\x06\x20\x01(\x0b2\x13.daml_\
    lf_1.LocationR\x08location\x1a:\n\x06Fields\x120\n\x06fields\x18\x01\x20\
    \x03(\x0b2\x18.daml_lf_1.FieldWithTypeR\x06fieldsB\n\n\x08DataCons\"\xcf\
    \x01\n\x08DefValue\x12(\n\x03var\x18\x01\x20\x01(\x0b2\x16.daml_lf_1.Var\
    WithTypeR\x03var\x12#\n\x04expr\x18\x02\x20\x01(\x0b2\x0f.daml_lf_1.Expr\
    R\x04expr\x12*\n\x11no_party_literals\x18\x03\x20\x01(\x08R\x0fnoPartyLi\
    terals\x12\x17\n\x07is_test\x18\x04\x20\x01(\x08R\x06isTest\x12/\n\x08lo\
    cation\x18\x05\x20\x01(\x0b2\x13.daml_lf_1.LocationR\x08location\"\xfa\
    \x01\n\x0cFeatureFlags\x120\n\x13forbidPartyLiterals\x18\x01\x20\x01(\
    \x08R\x13forbidPartyLiterals\x12X\n'dontDivulgeContractIdsInCreateArgume\
    nts\x18\x02\x20\x01(\x08R'dontDivulgeContractIdsInCreateArguments\x12^\n\
    *dontDiscloseNonConsumingChoicesToObservers\x18\x03\x20\x01(\x08R*dontDi\
    scloseNonConsumingChoicesToObservers\"\x88\x02\n\x06Module\x12)\n\x04nam\
    e\x18\x01\x20\x01(\x0b2\x15.daml_lf_1.DottedNameR\x04name\x12-\n\x05flag\
    s\x18\x04\x20\x01(\x0b2\x17.daml_lf_1.FeatureFlagsR\x05flags\x125\n\ndat\
    a_types\x18\x05\x20\x03(\x0b2\x16.daml_lf_1.DefDataTypeR\tdataTypes\x12+\
    \n\x06values\x18\x06\x20\x03(\x0b2\x13.daml_lf_1.DefValueR\x06values\x12\
    4\n\ttemplates\x18\x07\x20\x03(\x0b2\x16.daml_lf_1.DefTemplateR\ttemplat\
    esJ\x04\x08\x02\x10\x03J\x04\x08\x03\x10\x04\"6\n\x07Package\x12+\n\x07m\
    odules\x18\x01\x20\x03(\x0b2\x11.daml_lf_1.ModuleR\x07modules*\x99\x01\n\
    \x08PrimType\x12\x08\n\x04UNIT\x10\0\x12\x08\n\x04BOOL\x10\x01\x12\t\n\
    \x05INT64\x10\x02\x12\x0b\n\x07DECIMAL\x10\x03\x12\x08\n\x04TEXT\x10\x05\
    \x12\r\n\tTIMESTAMP\x10\x06\x12\t\n\x05PARTY\x10\x08\x12\x08\n\x04LIST\
    \x10\t\x12\n\n\x06UPDATE\x10\n\x12\x0c\n\x08SCENARIO\x10\x0b\x12\x08\n\
    \x04DATE\x10\x0c\x12\x0f\n\x0bCONTRACT_ID\x10\r*4\n\x07PrimCon\x12\x0c\n\
    \x08CON_UNIT\x10\0\x12\r\n\tCON_FALSE\x10\x01\x12\x0c\n\x08CON_TRUE\x10\
    \x02*\xb1\x08\n\x0fBuiltinFunction\x12\x0f\n\x0bADD_DECIMAL\x10\0\x12\
    \x0f\n\x0bSUB_DECIMAL\x10\x01\x12\x0f\n\x0bMUL_DECIMAL\x10\x02\x12\x0f\n\
    \x0bDIV_DECIMAL\x10\x03\x12\x11\n\rROUND_DECIMAL\x10\x06\x12\r\n\tADD_IN\
    T64\x10\x07\x12\r\n\tSUB_INT64\x10\x08\x12\r\n\tMUL_INT64\x10\t\x12\r\n\
    \tDIV_INT64\x10\n\x12\r\n\tMOD_INT64\x10\x0b\x12\r\n\tEXP_INT64\x10\x0c\
    \x12\t\n\x05FOLDL\x10\x14\x12\t\n\x05FOLDR\x10\x15\x12\x10\n\x0cEXPLODE_\
    TEXT\x10\x17\x12\x0f\n\x0bAPPEND_TEXT\x10\x18\x12\t\n\x05ERROR\x10\x19\
    \x12\r\n\tLEQ_INT64\x10!\x12\x0f\n\x0bLEQ_DECIMAL\x10\"\x12\x0c\n\x08LEQ\
    _TEXT\x10$\x12\x11\n\rLEQ_TIMESTAMP\x10%\x12\x0c\n\x08LEQ_DATE\x10C\x12\
    \x0e\n\nLESS_INT64\x10'\x12\x10\n\x0cLESS_DECIMAL\x10(\x12\r\n\tLESS_TEX\
    T\x10*\x12\x12\n\x0eLESS_TIMESTAMP\x10+\x12\r\n\tLESS_DATE\x10D\x12\r\n\
    \tGEQ_INT64\x10-\x12\x0f\n\x0bGEQ_DECIMAL\x10.\x12\x0c\n\x08GEQ_TEXT\x10\
    0\x12\x11\n\rGEQ_TIMESTAMP\x101\x12\x0c\n\x08GEQ_DATE\x10E\x12\x11\n\rGR\
    EATER_INT64\x103\x12\x13\n\x0fGREATER_DECIMAL\x104\x12\x10\n\x0cGREATER_\
    TEXT\x106\x12\x15\n\x11GREATER_TIMESTAMP\x107\x12\x10\n\x0cGREATER_DATE\
    \x10F\x12\x11\n\rTO_TEXT_INT64\x109\x12\x13\n\x0fTO_TEXT_DECIMAL\x10:\
    \x12\x10\n\x0cTO_TEXT_TEXT\x10<\x12\x15\n\x11TO_TEXT_TIMESTAMP\x10=\x12\
    \x10\n\x0cTO_TEXT_DATE\x10G\x12\x11\n\rTO_TEXT_PARTY\x10?\x12\x15\n\x11D\
    ATE_TO_UNIX_DAYS\x10H\x12\x15\n\x11UNIX_DAYS_TO_DATE\x10I\x12\"\n\x1eTIM\
    ESTAMP_TO_UNIX_MICROSECONDS\x10J\x12\"\n\x1eUNIX_MICROSECONDS_TO_TIMESTA\
    MP\x10K\x12\x14\n\x10INT64_TO_DECIMAL\x10L\x12\x14\n\x10DECIMAL_TO_INT64\
    \x10M\x12\x10\n\x0cIMPLODE_TEXT\x10N\x12\x0f\n\x0bEQUAL_INT64\x10O\x12\
    \x11\n\rEQUAL_DECIMAL\x10P\x12\x0e\n\nEQUAL_TEXT\x10Q\x12\x13\n\x0fEQUAL\
    _TIMESTAMP\x10R\x12\x0e\n\nEQUAL_DATE\x10S\x12\x0f\n\x0bEQUAL_PARTY\x10T\
    \x12\x0e\n\nEQUAL_BOOL\x10U\x12\x15\n\x11EQUAL_CONTRACT_ID\x10V\x12\x0e\
    \n\nEQUAL_LIST\x10W\x12\t\n\x05TRACE\x10XB\x1a\n\x18com.digitalasset.dam\
    l_lfb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
